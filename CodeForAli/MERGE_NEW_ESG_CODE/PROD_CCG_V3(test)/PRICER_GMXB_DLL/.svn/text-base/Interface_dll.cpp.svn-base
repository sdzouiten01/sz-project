#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>

#include "stdafx.h"
#include <ctime>
#include "Utility classes/head.h"
#include "Utility classes/back_ground_final.h"
#include <string>
#include <fstream>
#include <sstream>
#include <time.h>
#include <dos.h>
#include "Utility classes/functions.h"
#include "GMXBExcelXMLReader.h"
#include "GMXBException.h"
#include "GMXBParameters.h"
#include "Utility classes/Message.h"
#include "Utility classes/Scenario_configuration.h"
#include "Utility classes/Product_configuration.h"
#include "Utility classes/Stat_Inforce_Configuration.h"
#include "WildcardManager.h"
#include "Utility classes/fund_manager.h"
#include "InterfaceEsg.h"
#include "InterfaceCalibration.h"
#include "Utility classes/bucket_list.h"
#include "Utility classes/Scenario_list.h"
#include "Utility classes/Dispatch_Manager.h"
#include "Utility classes/Aging_Policies_configuration.h"
#include "Utility classes/fund_for_aging_policies.h"
#include "Utility classes/MP_AP_BOM.h"
#include "Utility classes/MP_AP_BOM_no_LD.h"
#include "Utility classes/MP_AP_EOM.h"
#include "Utility classes/MP_AP_EOM_no_NB.h"
#include "Utility classes/inforces_AP.h"


#include "safe_reader.h"
#include "../HEDGEFF_COMPUTE/Portfolio.h"

#define REFERENCE_FILE 0
#define FILE_TO_COMPARE 1
#define OUTPUT_RESULTS 2

/*
* price a set of product (defined in parameter_file)
* with a table of scenarios build by an external program. 
* This method is called by MoSes
* string& parameter_file : file containing the description of the payoffs
* ofstream& log_strm : stream used for logging
* double*** va_scen : scenarios (generated by MoSes)
* int scen_pass_number: id of the scenario
* int tot_nb_workers : total number of workers
* int w_id : id of the current worker
* double alpha : alpha parameter (calibration)
* double sigma : sigma parameter (calibration)
*/
extern "C"
{
/*
* Launch projection with scenario file
* price a set of product (defined in parameter_file)
* with a table of scenarios build by an external program. 
* summarize (i.e aggregate the results and calculate the mean) the results 
* after a call of price
*/
_declspec (dllexport) int run_HA_file_mode(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int price_file_mode(string& parameter_file, ofstream& log_strm,  int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int summarize(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* Statistics on the inforce
*/
_declspec (dllexport) int stat_inforce(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* Launch ESG and projection with the DLL
* summarize (i.e aggregate the results and calculate the mean) the results 
* after a call of price. This version is for the global pricing (esg + projection by DLL)
*/
_declspec (dllexport) int run_HA_esg_mode(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int esg_projection(string& config_Projection, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int summarize_esg(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* deprecated functions ... TO DO remove this function
*/
int _declspec (dllexport)price_with_different_seed( string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
int _declspec (dllexport)non_reg_tests(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* delete_intermediate_files : This function deletes all the intermediate files generated by the workers.
* Must be used before each run
* check_assumptions : check all the configuration paths	
* copy_assumptions : copy all the assumptions before the run 
*/
_declspec (dllexport) int delete_intermediate_files(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int check_assumptions(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int copy_assumptions(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* Launch calibration standalone with the DLL
*/
_declspec (dllexport) int run_calibration_standalone(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);


/*
* ESG stand alone
*/
_declspec (dllexport) int run_esg_standalone(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);
_declspec (dllexport) int esg_standalone(string& config_ESG,ofstream& log_strm,int nb_of_workers,int worker_id, string& s);

/*
* Calibration stand alone
*/
_declspec (dllexport) int calibration_standalone(string& config_calib, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* Risk Appetite
*/
_declspec (dllexport) int price_RA(string& parameter_file, ofstream& log_strm,  int nb_of_workers, int worker_id, string &s);
_declspec (dllexport) int summarize_RA(string& parameter_file, ofstream& log_strm, int nb_of_workers, int worker_id, string &s);
_declspec (dllexport) int run_RA_mode(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

/*
* Ageing Policies - Actuarial Tool
*/
_declspec (dllexport) int run_aging_policies( string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

_declspec (dllexport) void XML_set(const string& xml_file,const map<string,map<string,string>>& pack);


///////////////Hedge Effectiveness Part//////////////////////////
_declspec (dllexport)int InterfacePriceHE( string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s);
_declspec (dllexport)int InterfaceSummarizeHE(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s);

_declspec (dllexport) int InterfacePriceHeAsset(string& config, ofstream& log_strm, int tot_nb_workers, int w_id, string& s);
_declspec (dllexport) int InterfaceSummarizeHeAsset(string& config, ofstream& log_strm, int tot_nb_workers, int w_id_, string& s);
_declspec (dllexport) int price_he_asset(string& parameter_file, ofstream& log_strm, int tot_nb_workers, int w_id, string& s);
_declspec (dllexport) int summarize_he_asset(string& parameter_file, ofstream& log_strm, int tot_nb_workers, int w_id_, string& s);
//////////////////////////////////////////////////////////////////
}

ofstream trace;
ofstream trace_out;
ofstream trace_in;

bool compare_shock(vector<int> shock_element1, vector<int> shock_element2)
{
	if (shock_element1[0]<shock_element2[0])
	{
		return 1;
	}
	else if (shock_element1[0]==shock_element2[0])
	{
		return (shock_element1[1]<shock_element2[1]);
	}
	else
	{
		return 0;
	}
}

bool is_same_shock(vector<int> shock_element1, vector<int> shock_element2)
{
	if ((shock_element1[0]==shock_element2[0])&&(shock_element1[1]==shock_element2[1]))
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

string nb_to_string(int i)
{
	string s;
	stringstream sstr;
	sstr << i;
	sstr >> s;
	return s;
}


string nb_to_string(double d){
	string s;
	stringstream sstr;
	sstr << d;
	sstr >> s;
	return s;
}

/* @ Yann & Andrei (V13.0)
** This parsing used for MSO is not working correctly
** The use of the usual parsing with ';' generates bugs
*/
//void parse_index(const string& string_to_parse, vector<vector<int>>& shock_array_vector, int index_number)
//{
//	istringstream index_streamed(string_to_parse);
//	string delta_step;
//
//	while (getline(index_streamed, delta_step, ';'))
//	{
//		//Sheng: modif
//		if (delta_step.find_first_of('#') != -1) //for exampe deta_step = "-100#-50*2"
//		{
//			int shock_sup, shock_inf, step;
//			int pos_sharp = delta_step.find_first_of('#');
//			int pos_star = delta_step.find_first_of('*');
//			shock_inf =atoi(delta_step.substr(0, delta_step.length()-1).c_str());
//			shock_sup = atoi(delta_step.substr(pos_sharp+1, delta_step.length()-1).c_str());
//			step = atoi(delta_step.substr(pos_star+1,delta_step.length()-1).c_str());
//			for (int shock_size = shock_inf; shock_size <= shock_sup; shock_size+=step)
//			{
//				vector<int> delta_steps;
//				for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
//					delta_steps.push_back(0);
//				delta_steps[0] = index_number;
//				delta_steps[index_number] = shock_size;
//				shock_array_vector.push_back(delta_steps);
//			}
//		}		
//		else
//		{
//			vector<int> delta_steps;
//			for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
//				delta_steps.push_back(0);
//
//			delta_steps[0] = index_number;
//			delta_steps[index_number] = atoi(delta_step.c_str());
//			shock_array_vector.push_back(delta_steps);
//		}
//	}
//	sort (shock_array_vector.begin(),shock_array_vector.end(),compare_shock);
//	vector<vector<int>>::iterator it;
//	it=unique(shock_array_vector.begin(),shock_array_vector.end(),is_same_shock);
//	shock_array_vector.resize(it-shock_array_vector.begin());
//}

void parse_index(const string& string_to_parse, vector<vector<int>>& shock_array_vector, int index_number)
{
	istringstream index_streamed(string_to_parse);
	string delta_step;

	while (getline(index_streamed, delta_step, ';'))
	{
		vector<int> delta_steps;
		for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
			delta_steps.push_back(0);

			delta_steps[0] = index_number;
			delta_steps[index_number] = atoi(delta_step.c_str());
			shock_array_vector.push_back(delta_steps);
	}
}

void parse_index_esg(const string& string_to_parse, vector<vector<int>>& shock_array_vector, int index_number)
{
	istringstream index_streamed(string_to_parse);
	string delta_step;

	while (getline(index_streamed, delta_step, ';'))
	{
		vector<int> delta_steps;
		for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
			delta_steps.push_back(0);

			delta_steps[0] = index_number;
			delta_steps[index_number] = atoi(delta_step.c_str());
			shock_array_vector.push_back(delta_steps);
	}
}

void trimString(string& str)   
{   
    size_t startpos = str.find_first_not_of(" \t"); 
    size_t endpos = str.find_last_not_of(" \t"); 
    if(( string::npos == startpos ) || ( string::npos == endpos))   
    {   
        str = "";   
    }   
    else  
        str = str.substr( startpos, endpos-startpos+1 );
} 


// TODO - remove this function from here

int get_shock_number(const vector<vector<int>>& shock_array, int current_shock_number, int maximum_shocks, int maximum_number_of_instrument)
{
		if (shock_array.size())
		{
			if(shock_array[current_shock_number][0]==0)
				return 0;
			else if(shock_array[current_shock_number][0]==maximum_number_of_instrument+1)
			{
				if(shock_array[current_shock_number][1]>0)
				{
					return (maximum_shocks * maximum_number_of_instrument + shock_array[current_shock_number][1]);
				}
				else
				{
					return (maximum_shocks * (maximum_number_of_instrument+1) + 1 + shock_array[current_shock_number][1]);
				}
			 }
			else if(shock_array[current_shock_number][0]>0 && shock_array[current_shock_number][0]<=maximum_number_of_instrument)
			{
				if(shock_array[current_shock_number][shock_array[current_shock_number][0]]>0)
				{
					return (maximum_shocks * (shock_array[current_shock_number][0] - 1) + shock_array[current_shock_number][shock_array[current_shock_number][0]]);
				
				}
				else
				{
					return (maximum_shocks * shock_array[current_shock_number][0] + 1 + shock_array[current_shock_number][shock_array[current_shock_number][0]]);
				}
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "Bad configuration of the shock array");
				throw new GMXBException(message);		
			}
		}
		else
		{
			char message[MAX_LENGTH_MESSAGE_EXCEPTION];
			sprintf_s(message, "The shock array is empty");
			throw new GMXBException(message);		
		}
}

/*
* This function load the Hedge effectiveness outer loop 
* parameter and build Product_configuration and Scenario_configuration objects
*/
void load_run_configuration_he_outer(string& parameter_file, 
								vector<Product_configuration>& product_configurations, 
								string& trace_log_p,
								bool use_scn_file)
{

	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string> > map_products_configuration;
		map<string, vector<string> > map_run_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		string list_of_prod_to_run = safe_map_read(map_run_settings,"list_of_products_to_run",0);
		trace_log_p = wm.getPath(safe_map_read(map_run_settings,"trace_log_path",0));
		bool load_fund_param_files = false;
		
		// Load the "product_configuration" sheet
		xml_reader.parse_XML_sheet("product_configuration", map_products_configuration);

		istringstream list_of_runs_streamed(list_of_prod_to_run);
		string run_name;
		while (getline(list_of_runs_streamed, run_name, ','))
		{
			trimString(run_name);
			vector<string> list_of_configured_products = map_products_configuration["run_names"];
			// Try to find the run names
			int number_pf_configured_products = list_of_configured_products.size();
			if (number_pf_configured_products > 0)
			{
				bool found = false;
				int run_number = 0;
				for(int run_name_nb = 0 ; run_name_nb < number_pf_configured_products ; run_name_nb++)
				{
					if (list_of_configured_products[run_name_nb] == run_name)
					{
						found = true;
						run_number = run_name_nb;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The run name %s is not found in the product_configuration sheet (file %s) ", 
											run_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				/*
				** Search in the map if there is the field defined in quotes
				** If the word is found, a variable is settled to 1
				*/
				int find_longstaff_in_sheet = 0;

				for(map<string, vector<string> >::iterator map_iterator = map_products_configuration.begin(); map_iterator!= map_products_configuration.end(); map_iterator++)
				{   
					string field_in_sheet((*map_iterator).first) ;
					
					if (field_in_sheet == "do_longstaff")
						find_longstaff_in_sheet = 1;

				}

				vector<int> s_f_col;
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_0",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_1",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_2",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_3",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_4",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_5",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_6",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_7",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_8",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_9",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_10",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_11",run_number).c_str()));
						
				bool ext_all = false;
				if (safe_map_read(map_products_configuration,"extract_all_model_points",run_number) == "1")
					ext_all = true;

				bool generate_debug_files = false;

				if (safe_map_read(map_products_configuration,"generate_debug_files",run_number) == "1")
					generate_debug_files = true;

				//bool write_valo_pol_by_pol = false;
				//if (safe_map_read(map_products_configuration,"write_valo_policy_by_policy",run_number) == "1")
				//	write_valo_pol_by_pol = true;
				int write_valo_pol_by_pol = atoi(safe_map_read(map_products_configuration,"write_valo_policy_by_policy",run_number).c_str());

				bool project_funds = false;
				if (safe_map_read(map_products_configuration,"project_fund",run_number) == "1")
				{
					project_funds = true;
					load_fund_param_files = true;
				}

				if (load_fund_param_files)
				{
					Fund_Manager::init(parameter_file);
				}

				bool do_longstaff = false;

				if (find_longstaff_in_sheet == 1)
				{
					if (safe_map_read(map_products_configuration,"do_longstaff",run_number) == "1")
						do_longstaff = true;
					else if (safe_map_read(map_products_configuration,"do_longstaff",run_number) == "0")
						do_longstaff = false;
					else
					{
						char message[MAX_LENGTH_MESSAGE_EXCEPTION];
						sprintf_s(message, "The parameter do_longstaff must have only the values 0 and 1\n");
						throw new GMXBException(message);
					}
				}

				// Build the product configuration object
				Product_configuration p_c(safe_map_read(map_products_configuration,"run_names",run_number),
						wm.getPath(safe_map_read(map_products_configuration,"inforce_file_name",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"product_feature_file_name",run_number)),
						safe_map_read(map_products_configuration,"product_code_key_names",run_number),
						atoi(safe_map_read(map_products_configuration,"number_of_model_points",run_number).c_str()),
						ext_all,
						s_f_col,
						wm.getPath(safe_map_read(map_products_configuration,"result_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"debug_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"fund_split_param_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"management_fees_param_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"fund_valo_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"assumption_output_directory",run_number)),
						atoi(safe_map_read(map_products_configuration,"number_of_scenarios",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"yield_col_for_pv_index",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"lapse_dyn_treas",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"indice_index_rate",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"index_number",run_number).c_str()), generate_debug_files,
						write_valo_pol_by_pol, atoi(safe_map_read(map_products_configuration,"modulo_on_scenario",run_number).c_str()),
						project_funds,
						do_longstaff,
						atoi(safe_map_read(map_products_configuration,"shortsellable_fund_group",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"time_step",run_number).c_str()));
						
				if (do_longstaff == true)
				{
					string debug_file = safe_map_read(map_products_configuration,"debug_ls_output",run_number);
					string proba_file = safe_map_read(map_products_configuration,"proba_output",run_number);
					string proba_ls_file = safe_map_read(map_products_configuration,"proba_ls_output",run_number);

					p_c.set_longstaff_files(debug_file, proba_file, proba_ls_file);
				}
				
				// Handle the list of shocks
				istringstream shock_streamed(safe_map_read(map_products_configuration,"list_of_shocks",run_number));
				string shock_sheet;
				while (getline(shock_streamed, shock_sheet, ','))
				{
					trimString(shock_sheet);
					map<string, vector<string>> map_of_shock_settings;
					xml_reader.parse_XML_sheet(shock_sheet, map_of_shock_settings);

					string scenario_file = wm.getPath(safe_map_read(map_of_shock_settings,"scenario_file_path",0));
					int scenario_pass_number = atoi(safe_map_read(map_of_shock_settings,"scenario_pass_number",0).c_str());


					Scenario_configuration s_c(scenario_file,
												scenario_pass_number);

					p_c.add_scenario_configuration(s_c);
				}
				product_configurations.push_back(p_c);
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the run names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}


}
/*
* This function load all the parameter in a run configuration files like the initial load run conf
* The only difference is on the reading the informations of buckets in scenario sheet
*/
//! Y: Add map_run_settings by yuan for: map_products_configuration/map_of_shock_settings/map_run_settings
void load_run_configuration_esg(string& parameter_file, 
								vector<Product_configuration>& product_configurations, 
								//Scenario_list& scenario_list_table,
								//Bucket_list&   bucket_list_table,
								string& trace_log_p,
								bool use_scn_file
								//Dispatch_Manager& dispatch_manager
								)
{
	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string> > map_products_configuration;
		map<string, vector<string> > map_run_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		string list_of_prod_to_run = safe_map_read(map_run_settings,"list_of_products_to_run",0);
		trace_log_p = wm.getPath(safe_map_read(map_run_settings,"trace_log_path",0));
		bool load_fund_param_files = false;

		map<string, vector<string> > map_bucket_list;
		xml_reader.parse_XML_sheet("bucket_list", map_bucket_list);
        //bucket_list_table = Bucket_list(map_bucket_list);

		//int bucket_id;
		double bucketStartDate;
		double bucketKeyDate;
		double bucketEndDate;
		double bucketShockSize;
		string bucket_type;

		// Load the "product_configuration" sheet
		xml_reader.parse_XML_sheet("product_configuration", map_products_configuration);

		istringstream list_of_runs_streamed(list_of_prod_to_run);
		string run_name;

		while (getline(list_of_runs_streamed, run_name, ','))
		{
			trimString(run_name);
			vector<string> list_of_configured_products = map_products_configuration["run_names"];
			// Try to find the run names
			int number_pf_configured_products = list_of_configured_products.size();
			if (number_pf_configured_products > 0)
			{
				bool found = false;
				int run_number = 0;
				for(int run_name_nb = 0 ; run_name_nb < number_pf_configured_products ; run_name_nb++)
				{
					if (list_of_configured_products[run_name_nb] == run_name)
					{
						found = true;
						run_number = run_name_nb;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The run name %s is not found in the product_configuration sheet (file %s) ", 
											run_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				/*
				** Search in the map if there is the field defined in quotes
				** If the word is found, a variable is settled to 1
				*/
				int find_longstaff_in_sheet = 0;

				for(map<string, vector<string> >::iterator map_iterator = map_products_configuration.begin(); map_iterator!= map_products_configuration.end(); map_iterator++)
				{   
					string field_in_sheet((*map_iterator).first) ;
					
					if (field_in_sheet == "do_longstaff")
						find_longstaff_in_sheet = 1;

				}

				vector<int> s_f_col;
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_0",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_1",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_2",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_3",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_4",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_5",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_6",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_7",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_8",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_9",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_10",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_11",run_number).c_str()));
						
				bool ext_all = false;
				if (safe_map_read(map_products_configuration,"extract_all_model_points",run_number) == "1")
					ext_all = true;

				bool generate_debug_files = false;

				if (safe_map_read(map_products_configuration,"generate_debug_files",run_number) == "1")
					generate_debug_files = true;

				int write_valo_pol_by_pol = atoi((safe_map_read(map_products_configuration,"write_valo_policy_by_policy",run_number)).c_str());
                if(write_valo_pol_by_pol >2 || write_valo_pol_by_pol<0)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "Error in function load_run_configuration_esg(...): write_valo_pol_by_pol's value %d should not be other than : 0 or 1 or 2 ",write_valo_pol_by_pol);
					throw new GMXBException(message);
				}

				bool project_funds = false;
				if (safe_map_read(map_products_configuration,"project_fund",run_number) == "1")
				{
					project_funds = true;
					load_fund_param_files = true;
				}

				bool do_longstaff = false;

				if (find_longstaff_in_sheet == 1)
				{
					if (safe_map_read(map_products_configuration,"do_longstaff",run_number) == "1")
						do_longstaff = true;
					else if (safe_map_read(map_products_configuration,"do_longstaff",run_number) == "0")
						do_longstaff = false;
					else
					{
						char message[MAX_LENGTH_MESSAGE_EXCEPTION];
						sprintf_s(message, "The parameter do_longstaff must have only the values 0 and 1\n");
						throw new GMXBException(message);
					}
				}

				if (load_fund_param_files)
				{
					Fund_Manager::init(parameter_file);
				}
				
				// Build the product configuration object
				Product_configuration p_c(safe_map_read(map_products_configuration,"run_names",run_number),
						wm.getPath(safe_map_read(map_products_configuration,"inforce_file_name",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"product_feature_file_name",run_number)),
						safe_map_read(map_products_configuration,"product_code_key_names",run_number),
						atoi(safe_map_read(map_products_configuration,"number_of_model_points",run_number).c_str()),
						ext_all,
						s_f_col,
						wm.getPath(safe_map_read(map_products_configuration,"result_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"debug_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"fund_split_param_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"management_fees_param_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"fund_valo_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"assumption_output_directory",run_number)),
						atoi(safe_map_read(map_products_configuration,"number_of_scenarios",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"yield_col_for_pv_index",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"lapse_dyn_treas",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"indice_index_rate",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"index_number",run_number).c_str()), generate_debug_files,
						write_valo_pol_by_pol, atoi(safe_map_read(map_products_configuration,"modulo_on_scenario",run_number).c_str()),
						project_funds,
						do_longstaff,
						atoi(safe_map_read(map_products_configuration,"shortsellable_fund_group",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"time_step",run_number).c_str()));

		

				if (do_longstaff == true)
				{
					string debug_file = safe_map_read(map_products_configuration,"debug_ls_output",run_number);
					string proba_file = safe_map_read(map_products_configuration,"proba_output",run_number);
					string proba_ls_file = safe_map_read(map_products_configuration,"proba_ls_output",run_number);

					p_c.set_longstaff_files(debug_file, proba_file, proba_ls_file);
				}

				istringstream shock_streamed(safe_map_read(map_products_configuration,"list_of_shocks",run_number));
				string shock_sheet;
				while (getline(shock_streamed, shock_sheet, ','))
				{
					//string shock_sheet(safe_map_read(map_products_configuration,"list_of_shocks",run_number));
				trimString(shock_sheet);
				map<string, vector<string>> map_of_shock_settings;
				xml_reader.parse_XML_sheet(shock_sheet, map_of_shock_settings);

				int find_paid_up_in_sheet = 0;
				int find_election_in_sheet = 0;

				/*
				** Search in the map if there is the field defined in quotes
				** If the word is found, a variable is settled to 1
				*/
				for(map<string, vector<string> >::iterator map_iterator = map_of_shock_settings.begin(); map_iterator!= map_of_shock_settings.end(); map_iterator++)
				{   
					string field_in_sheet((*map_iterator).first) ;
					
					if (field_in_sheet == "paidup_shock")
						find_paid_up_in_sheet = 1;

					if (field_in_sheet == "election_shock")
						find_election_in_sheet = 1;
				}

				int nb_bucket_to_project = atoi(safe_map_read(map_of_shock_settings,"nb_bucket_to_project",0).c_str());

				int scenario_pass_number = atoi(safe_map_read(map_of_shock_settings,"scenario_pass_number",0).c_str());

				//! CHECK if two same bucket_id are used(but may exist)in the same scnario config
				vector<int> bucket_id_check_vector;
				for(int iterator_bucket_id_check =0; iterator_bucket_id_check<nb_bucket_to_project; ++iterator_bucket_id_check)
				{
					bucket_id_check_vector.push_back(atoi(safe_map_read(map_of_shock_settings,"bucket_id",iterator_bucket_id_check).c_str())); 
				}
				vector<int>::iterator check_itr = bucket_id_check_vector.begin();
				vector<int>::iterator check_itr_end = bucket_id_check_vector.end();
				while(check_itr!=check_itr_end)
				{
						int bucket_to_find = *check_itr;
						++check_itr;
						if(find(check_itr,check_itr_end, bucket_to_find) != check_itr_end) // find two buckets in the same scenario!
						{
							char message[MAX_LENGTH_MESSAGE_EXCEPTION];
							sprintf_s(message, "Error in the scenario's bucket config: the scenario_pass_number %d use two same bucket_id %d",scenario_pass_number, bucket_to_find);
							throw new GMXBException(message);
						}
				}

				for(int iterator_bucket_id =0; iterator_bucket_id<nb_bucket_to_project; iterator_bucket_id++)
				{
				
					vector<vector<int> > index_shock_array;
					vector<vector<int> > fund_shock_array;

					string run_baseline = safe_map_read(map_of_shock_settings,"run_baseline",iterator_bucket_id);
					string index_1 = safe_map_read(map_of_shock_settings,"index_1",iterator_bucket_id);
					string index_2 = safe_map_read(map_of_shock_settings,"index_2",iterator_bucket_id);
					string index_3 = safe_map_read(map_of_shock_settings,"index_3",iterator_bucket_id);
					string index_4 = safe_map_read(map_of_shock_settings,"index_4",iterator_bucket_id);
					string index_5 = safe_map_read(map_of_shock_settings,"index_5",iterator_bucket_id);
					string index_6 = safe_map_read(map_of_shock_settings,"index_6",iterator_bucket_id);
					string index_7 = safe_map_read(map_of_shock_settings,"index_7",iterator_bucket_id);
					string index_8 = safe_map_read(map_of_shock_settings,"index_8",iterator_bucket_id);
					string index_9 = safe_map_read(map_of_shock_settings,"index_9",iterator_bucket_id);
					string index_10 = safe_map_read(map_of_shock_settings,"index_10",iterator_bucket_id);
					string index_11 = safe_map_read(map_of_shock_settings,"index_11",iterator_bucket_id);
					string index_12 = safe_map_read(map_of_shock_settings,"index_12",iterator_bucket_id);
					string delta_global = safe_map_read(map_of_shock_settings,"delta_global",iterator_bucket_id);
					string  shock_funds_str = safe_map_read(map_of_shock_settings,"shock_funds",iterator_bucket_id);
						
					bool shock_funds = false;

					if (shock_funds_str == "1")
							shock_funds = true;
						
					string list_of_fund_shocks = safe_map_read(map_of_shock_settings,"fund_shock_amplitude",iterator_bucket_id);
					string lapse_shock = safe_map_read(map_of_shock_settings,"lapse_shock",iterator_bucket_id);
					
					string paidup_shock;
					string election_shock;

					if (find_paid_up_in_sheet == 1)
						paidup_shock = safe_map_read(map_of_shock_settings,"paidup_shock",iterator_bucket_id);
					else
						paidup_shock = "0";

					if (find_election_in_sheet == 1)
						election_shock = safe_map_read(map_of_shock_settings,"election_shock",iterator_bucket_id);
					else
						election_shock = "0";
					
					string mortality_shock = safe_map_read(map_of_shock_settings,"mort_shock",iterator_bucket_id);
					string longevity_shock = safe_map_read(map_of_shock_settings,"longevity_shock",iterator_bucket_id);

					// Load informations about the buckets
					int bucket_id = atoi(safe_map_read(map_of_shock_settings,"bucket_id",iterator_bucket_id).c_str()); 

					for(map<string, vector<string>>::iterator bucket_list_iterator = map_bucket_list.begin();
						bucket_list_iterator!=map_bucket_list.end();
						bucket_list_iterator++)
					{
						if((*bucket_list_iterator).first == "id")
							continue;
						if( atoi((*bucket_list_iterator).first.c_str()) == bucket_id)
						{
							string key = (*bucket_list_iterator).first;

							bucketStartDate  = atof(safe_map_read(map_bucket_list,key,1).c_str() ); 
							bucketKeyDate    = atof(safe_map_read(map_bucket_list,key,2).c_str()); 
							bucketEndDate    = atof(safe_map_read(map_bucket_list,key,3).c_str()); 
							bucketShockSize  = atof(safe_map_read(map_bucket_list,key,4).c_str())/100.0; 	
							bucket_type      = map_bucket_list[key][0]; 
						}
					}

					vector<GMXB_Assumption_Table *> v_lapse_mult;
					vector<GMXB_Assumption_Table *> v_mortality_mult;
					vector<GMXB_Assumption_Table *> v_paidup_mult;
					vector<GMXB_Assumption_Table *> v_election_mult;

					if (run_baseline != "0")
					{
						vector<int> delta_step;
						for (int j = 0; j <= MAXIMUM_NUMBER_OF_INDEXES; j++)
							delta_step.push_back(0);
						index_shock_array.push_back(delta_step);
					}
					if (index_1 != "0")
					{
						parse_index_esg(index_1, index_shock_array, 1);
					}
					if (index_2 != "0")
					{
						parse_index_esg(index_2 , index_shock_array, 2);
					}
					if (index_3  != "0")
					{
						parse_index_esg(index_3 , index_shock_array, 3);
					}
					if (index_4  != "0")
					{
						parse_index_esg(index_4 , index_shock_array, 4);
					}
					if (index_5  != "0")
					{
						parse_index_esg(index_5 , index_shock_array, 5);
					}
					if (index_6  != "0")
					{
						parse_index_esg(index_6 , index_shock_array, 6);
					}
					if (index_7  != "0")
					{
						parse_index_esg(index_7 , index_shock_array, 7);
					}
					if (index_8  != "0")
					{
						parse_index_esg(index_8 , index_shock_array, 8);
					}
					if (index_9  != "0")
					{
						parse_index_esg(index_9 , index_shock_array, 9);
					}
					if (index_10  != "0")
					{
						parse_index_esg(index_10 , index_shock_array, 10);
					}
					if (index_11  != "0")
					{
						parse_index_esg(index_11 , index_shock_array, 11);
					}
					if (index_12  != "0")
					{
						parse_index_esg(index_12 , index_shock_array, 12);
					}
					if (delta_global  != "0")
					{
						istringstream index_streamed(delta_global);
						string delta_step;
						while (getline(index_streamed, delta_step, ';'))
						{	
							vector<int> delta_steps;
							for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
								delta_steps.push_back(atoi(delta_step.c_str()));
							delta_steps[0] = MAXIMUM_NUMBER_OF_INDEXES + 1;
							index_shock_array.push_back(delta_steps);
						}
					}

					if (load_fund_param_files)
					{
						if (shock_funds)
						{
							// get the number of funds
							int nb_funds = p_c.get_number_of_funds();
							// Parse the list_of_fund_shocks variable
							vector<int> v_shocks;
							istringstream list_of_fund_shocks_str;
							list_of_fund_shocks_str.str(list_of_fund_shocks);
							string element;

							while (getline(list_of_fund_shocks_str, element, ';') )
							{
								v_shocks.push_back(atoi(element.c_str()));
							}

							vector<int> fund_ids = p_c.get_list_of_fund_id_by_group_id(p_c.get_shortsellable_group());
							for (unsigned int i=0; i < fund_ids.size(); i++)
							{
								int f_id = fund_ids[i];
								for (unsigned int j = 0; j < v_shocks.size(); j++)
								{
									int shock_value = v_shocks[j];
									vector<int> v_shock_fund;
									v_shock_fund.push_back(f_id);
									for (int k=1; k <= nb_funds; k++)
									{
										if (k == f_id)
											v_shock_fund.push_back(shock_value);
										else
											v_shock_fund.push_back(0);
									}
									fund_shock_array.push_back(v_shock_fund);
								}
							}
						}
					}

					if (lapse_shock  != "0")
					{
						istringstream lapse_mult_streamed(lapse_shock);
						string lapse_mult_table;
						while (getline(lapse_mult_streamed, lapse_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_lapse = new GMXB_Assumption_Table(parameter_file,
												lapse_mult_table);
							v_lapse_mult.push_back(mult_table_lapse);
						}
					}

					if (mortality_shock  != "0")
					{

						istringstream mortality_mult_streamed(mortality_shock);
						string mortality_mult_table;
						while (getline(mortality_mult_streamed, mortality_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_mortality = new GMXB_Assumption_Table(parameter_file,
												mortality_mult_table);
							v_mortality_mult.push_back(mult_table_mortality);
						}
					}

					if (paidup_shock  != "0")
					{

						istringstream paidup_mult_streamed(paidup_shock);
						string paidup_mult_table;
						while (getline(paidup_mult_streamed, paidup_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_paidup = new GMXB_Assumption_Table(parameter_file,
												paidup_mult_table);
							v_paidup_mult.push_back(mult_table_paidup);
						}
					}
					if (election_shock  != "0")
					{

						istringstream election_mult_streamed(election_shock);
						string election_mult_table;
						while (getline(election_mult_streamed, election_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_election = new GMXB_Assumption_Table(parameter_file,
												election_mult_table);
							v_election_mult.push_back(mult_table_election);
						}
					}
					bool load_longevity_table = false;
					if (longevity_shock == "1")
						load_longevity_table = true;

					Scenario_configuration s_c("Nothing used",
												scenario_pass_number,
												index_shock_array,
												fund_shock_array,
												bucketStartDate,
												bucketKeyDate,
												bucketEndDate,
												bucketShockSize,
												bucket_type, 
												bucket_id,
												use_scn_file,
												shock_funds,
												v_lapse_mult, 
												v_mortality_mult,
												v_paidup_mult,
												v_election_mult,
												load_longevity_table);

					p_c.add_scenario_configuration(s_c);
				}
				}
				product_configurations.push_back(p_c);
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the run names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}


//! File Mode or Moses Mode: No buckets! 
/*
* This function load all the parameter in a run configuration files
* The main sheets of the run configuration file are :
* wildcards : This sheet contains all the aliases of the paths used in the file
* runs_configuration : This sheet contains the list of the product to run as well as some parameters used by all the runs
* product_configuration : This sheet contains the description of all the payoffs 
*/

//! Y: Add map_run_settings by yuan for: map_products_configuration/map_of_shock_settings/map_run_settings
void load_run_configuration(string& parameter_file, 
							vector<Product_configuration>& product_configurations, 
							string& trace_log_p,
							bool use_scn_file
							)
{

	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string> > map_products_configuration;
		map<string, vector<string> > map_run_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		string list_of_prod_to_run = safe_map_read(map_run_settings,"list_of_products_to_run",0);
		trace_log_p = wm.getPath(safe_map_read(map_run_settings,"trace_log_path",0));
		bool load_fund_param_files = false;
		
		// Load the "product_configuration" sheet
		xml_reader.parse_XML_sheet("product_configuration", map_products_configuration);

		istringstream list_of_runs_streamed(list_of_prod_to_run);
		string run_name;
		while (getline(list_of_runs_streamed, run_name, ','))
		{
			trimString(run_name);
			vector<string> list_of_configured_products = map_products_configuration["run_names"];
			// Try to find the run names
			int number_pf_configured_products = list_of_configured_products.size();
			if (number_pf_configured_products > 0)
			{
				bool found = false;
				int run_number = 0;
				for(int run_name_nb = 0 ; run_name_nb < number_pf_configured_products ; run_name_nb++)
				{
					if (list_of_configured_products[run_name_nb] == run_name)
					{
						found = true;
						run_number = run_name_nb;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The run name %s is not found in the product_configuration sheet (file %s) ", 
											run_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				/*
				** Search in the map if there is the field defined in quotes
				** If the word is found, a variable is settled to 1
				*/
				int find_longstaff_in_sheet = 0;

				for(map<string, vector<string> >::iterator map_iterator = map_products_configuration.begin(); map_iterator!= map_products_configuration.end(); map_iterator++)
				{   
					string field_in_sheet((*map_iterator).first) ;
					
					if (field_in_sheet == "do_longstaff")
						find_longstaff_in_sheet = 1;

				}

				vector<int> s_f_col;
			
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_0",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_1",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_2",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_3",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_4",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_5",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_6",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_7",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_8",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_9",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_10",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_11",run_number).c_str()));
						
				bool ext_all = false;
				if (safe_map_read(map_products_configuration,"extract_all_model_points",run_number) == "1")
					ext_all = true;

				bool generate_debug_files = false;

				if (safe_map_read(map_products_configuration,"generate_debug_files",run_number) == "1")
					generate_debug_files = true;

				int write_valo_pol_by_pol = atoi(safe_map_read(map_products_configuration,"write_valo_policy_by_policy",run_number).c_str());
                if(write_valo_pol_by_pol >2 || write_valo_pol_by_pol<0)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "Error in function load_run_configuration(...): write_valo_pol_by_pol's value %d should not be other than : 0 or 1 or 2 ",write_valo_pol_by_pol);
					throw new GMXBException(message);
				}
				

				bool project_funds = false;
				if (safe_map_read(map_products_configuration,"project_fund",run_number) == "1")
				{
					project_funds = true;
					load_fund_param_files = true;
				}

				bool do_longstaff = false;

				if (find_longstaff_in_sheet == 1)
				{
					if (safe_map_read(map_products_configuration,"do_longstaff",run_number) == "1")
						do_longstaff = true;
					else if (safe_map_read(map_products_configuration,"do_longstaff",run_number) == "0")
						do_longstaff = false;
					else
					{
						char message[MAX_LENGTH_MESSAGE_EXCEPTION];
						sprintf_s(message, "The parameter do_longstaff must have only the values 0 and 1\n");
						throw new GMXBException(message);
					}
				}

				if (load_fund_param_files)
				{
					Fund_Manager::init(parameter_file);
				}

				// Build the product configuration object
				Product_configuration p_c(safe_map_read(map_products_configuration,"run_names",run_number),
						wm.getPath(safe_map_read(map_products_configuration,"inforce_file_name",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"product_feature_file_name",run_number)),
						safe_map_read(map_products_configuration,"product_code_key_names",run_number),
						atoi(safe_map_read(map_products_configuration,"number_of_model_points",run_number).c_str()),
						ext_all,
						s_f_col,
						wm.getPath(safe_map_read(map_products_configuration,"result_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"debug_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"fund_split_param_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"management_fees_param_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"fund_valo_file",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"assumption_output_directory",run_number)),
						atoi(safe_map_read(map_products_configuration,"number_of_scenarios",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"yield_col_for_pv_index",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"lapse_dyn_treas",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"indice_index_rate",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"index_number",run_number).c_str()), generate_debug_files,
						write_valo_pol_by_pol, atoi(safe_map_read(map_products_configuration,"modulo_on_scenario",run_number).c_str()),
						project_funds,
						do_longstaff,
						atoi(safe_map_read(map_products_configuration,"shortsellable_fund_group",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"time_step",run_number).c_str()));
				
				if (do_longstaff == true)
				{
					string debug_file = wm.getPath(safe_map_read(map_products_configuration,"debug_ls_output",run_number));
					string proba_file = wm.getPath(safe_map_read(map_products_configuration,"proba_output",run_number));
					string proba_ls_file = wm.getPath(safe_map_read(map_products_configuration,"proba_ls_output",run_number));

					p_c.set_longstaff_files(debug_file, proba_file, proba_ls_file);
				}

				// Handle the list of shocks
				istringstream shock_streamed(safe_map_read(map_products_configuration,"list_of_shocks",run_number));
				string shock_sheet;
				while (getline(shock_streamed, shock_sheet, ','))
				{
					trimString(shock_sheet);
					map<string, vector<string>> map_of_shock_settings;
					xml_reader.parse_XML_sheet(shock_sheet, map_of_shock_settings);

					int find_paid_up_in_sheet = 0;
					int find_election_in_sheet = 0;

					/*
					** Search in the map if there is the field defined in quotes
					** If the word is found, a variable is settled to 1
					*/
					for(map<string, vector<string> >::iterator map_iterator = map_of_shock_settings.begin(); map_iterator!= map_of_shock_settings.end(); map_iterator++)
					{   
						string field_in_sheet((*map_iterator).first) ;
						
						if (field_in_sheet == "paidup_shock")
							find_paid_up_in_sheet = 1;

						if (field_in_sheet == "election_shock")
							find_election_in_sheet = 1;
					}

					string scenario_file = wm.getPath(safe_map_read(map_of_shock_settings,"scenario_file_path",0));
					int scenario_pass_number = atoi(safe_map_read(map_of_shock_settings,"scenario_pass_number",0).c_str());
					vector<vector<int> > index_shock_array;
					vector<vector<int> > fund_shock_array;

					string run_baseline = safe_map_read(map_of_shock_settings,"run_baseline",0);
					string index_1 = safe_map_read(map_of_shock_settings,"index_1",0);
					string index_2 = safe_map_read(map_of_shock_settings,"index_2",0);
					string index_3 = safe_map_read(map_of_shock_settings,"index_3",0);
					string index_4 = safe_map_read(map_of_shock_settings,"index_4",0);
					string index_5 = safe_map_read(map_of_shock_settings,"index_5",0);
					string index_6 = safe_map_read(map_of_shock_settings,"index_6",0);
					string index_7 = safe_map_read(map_of_shock_settings,"index_7",0);
					string index_8 = safe_map_read(map_of_shock_settings,"index_8",0);
					string index_9 = safe_map_read(map_of_shock_settings,"index_9",0);
					string index_10 = safe_map_read(map_of_shock_settings,"index_10",0);
					string index_11 = safe_map_read(map_of_shock_settings,"index_11",0);
					string index_12 = safe_map_read(map_of_shock_settings,"index_12",0);
					string delta_global = safe_map_read(map_of_shock_settings,"delta_global",0);
					string  shock_funds_str = safe_map_read(map_of_shock_settings,"shock_funds",0);
					
					bool shock_funds = false;

					if (shock_funds_str == "1")
							shock_funds = true;
					
					
					string list_of_fund_shocks = safe_map_read(map_of_shock_settings,"fund_shock_amplitude",0);
			
					string lapse_shock = safe_map_read(map_of_shock_settings,"lapse_shock",0);
				
					//Mortality modif shocks
					string mortality_shock = safe_map_read(map_of_shock_settings,"mort_shock",0);
				
					//Longevity modif shocks
					string longevity_shock = safe_map_read(map_of_shock_settings,"longevity_shock",0);
				
					//Paidup & election shocks modif
					string paidup_shock;
					string election_shock;
					
					if (find_paid_up_in_sheet == 1)
						paidup_shock = safe_map_read(map_of_shock_settings,"paidup_shock",0);
					else
						paidup_shock = "0";

					if (find_election_in_sheet == 1)
						election_shock = safe_map_read(map_of_shock_settings,"election_shock",0);
					else
						election_shock = "0";

					vector<GMXB_Assumption_Table *> v_lapse_mult;
					vector<GMXB_Assumption_Table *> v_mortality_mult;
					vector<GMXB_Assumption_Table *> v_paidup_mult;
					vector<GMXB_Assumption_Table *> v_election_mult;

					if (run_baseline != "0")
					{
						vector<int> delta_step;
						for (int j = 0; j <= MAXIMUM_NUMBER_OF_INDEXES; j++)
							delta_step.push_back(0);
						index_shock_array.push_back(delta_step);
					}
					if (index_1 != "0")
					{
						parse_index(index_1, index_shock_array, 1);
					}
					if (index_2 != "0")
					{
						parse_index(index_2 , index_shock_array, 2);
					}
					if (index_3  != "0")
					{
						parse_index(index_3 , index_shock_array, 3);
					}
					if (index_4  != "0")
					{
						parse_index(index_4 , index_shock_array, 4);
					}
					if (index_5  != "0")
					{
						parse_index(index_5 , index_shock_array, 5);
					}
					if (index_6  != "0")
					{
						parse_index(index_6 , index_shock_array, 6);
					}
					if (index_7  != "0")
					{
						parse_index(index_7 , index_shock_array, 7);
					}
					if (index_8  != "0")
					{
						parse_index(index_8 , index_shock_array, 8);
					}
					if (index_9  != "0")
					{
						parse_index(index_9 , index_shock_array, 9);
					}
					if (index_10  != "0")
					{
						parse_index(index_10 , index_shock_array, 10);
					}
					if (index_11  != "0")
					{
						parse_index(index_11 , index_shock_array, 11);
					}
					if (index_12  != "0")
					{
						parse_index(index_12 , index_shock_array, 12);
					}

					if (delta_global  != "0")
					{
						istringstream index_streamed(delta_global);
						string delta_step;
						while (getline(index_streamed, delta_step, ';'))
						{	
							vector<int> delta_steps;
							for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
								delta_steps.push_back(atoi(delta_step.c_str()));
							delta_steps[0] = MAXIMUM_NUMBER_OF_INDEXES + 1;
							index_shock_array.push_back(delta_steps);
						}
					}
					
					/* @ Yann & Andrei
					** This parsing used for MSO is not working correctly
					** The use of the usual parsing with ';' generates bugs
					*/
					//if (delta_global  != "0")
					//{
					//	istringstream index_streamed(delta_global);
					//	string delta_step;
					//	while (getline(index_streamed, delta_step, ';'))
					//	{if (delta_step.find_first_of('#') != -1) //for exampe deta_step = "-100#-50*2"
					//		{
					//			int shock_sup, shock_inf, step;
					//			int pos_sharp = delta_step.find_first_of('#');
					//			int pos_star = delta_step.find_first_of('*');
					//			shock_inf =atoi(delta_step.substr(0, delta_step.length()-1).c_str());
					//			shock_sup = atoi(delta_step.substr(pos_sharp+1, delta_step.length()-1).c_str());
					//			step = atoi(delta_step.substr(pos_star+1,delta_step.length()-1).c_str());
					//			for (int shock_size = shock_inf; shock_size <= shock_sup; shock_size+=step)
					//			{
					//				vector<int> delta_steps;
					//				for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
					//					delta_steps.push_back(shock_size);
					//				delta_steps[0] = 13;
					//				index_shock_array.push_back(delta_steps);
					//			}
					//		}		
					//		else
					//		{
					//			vector<int> delta_steps;
					//			for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
					//				delta_steps.push_back(atoi(delta_step.c_str()));
					//			delta_steps[0] = 13;
					//			index_shock_array.push_back(delta_steps);
					//		}
					//	}
					//	sort (index_shock_array.begin(),index_shock_array.end(),compare_shock);
					//                   vector<vector<int>>::iterator it;
					 //                it=unique(index_shock_array.begin(),index_shock_array.end(),is_same_shock);
					 //                index_shock_array.resize(it-index_shock_array.begin());
					//}

					if (load_fund_param_files)
					{
						if (shock_funds)
						{
							// get the number of funds
							int nb_funds = p_c.get_number_of_funds();
							// Parse the list_of_fund_shocks variable
							vector<int> v_shocks;
							istringstream list_of_fund_shocks_str;
							list_of_fund_shocks_str.str(list_of_fund_shocks);
							string element;
							while (getline(list_of_fund_shocks_str, element, ';') )
							{
								v_shocks.push_back(atoi(element.c_str()));
							}
							vector<int> fund_ids = p_c.get_list_of_fund_id_by_group_id(p_c.get_shortsellable_group());
							for (unsigned int i=0; i < fund_ids.size(); i++)
							{
								int f_id = fund_ids[i];
								for (unsigned int j = 0; j < v_shocks.size(); j++)
								{
									int shock_value = v_shocks[j];
									vector<int> v_shock_fund;
									v_shock_fund.push_back(f_id);
									for (int k=1; k <= nb_funds; k++)
									{
										if (k == f_id)
											v_shock_fund.push_back(shock_value);
										else
											v_shock_fund.push_back(0);
									}
									fund_shock_array.push_back(v_shock_fund);
								}
							}
						}
					}
					if (lapse_shock  != "0")
					{

						istringstream lapse_mult_streamed(lapse_shock);
						string lapse_mult_table;
						while (getline(lapse_mult_streamed, lapse_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_lapse = new GMXB_Assumption_Table(parameter_file,
												lapse_mult_table);
							v_lapse_mult.push_back(mult_table_lapse);
						}
					}

					if (mortality_shock  != "0")
					{

						istringstream mortality_mult_streamed(mortality_shock);
						string mortality_mult_table;
						while (getline(mortality_mult_streamed, mortality_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_mortality = new GMXB_Assumption_Table(parameter_file,
												mortality_mult_table);
							v_mortality_mult.push_back(mult_table_mortality);
						}
					}
					if (paidup_shock  != "0")
					{

						istringstream paidup_mult_streamed(paidup_shock);
						string paidup_mult_table;
						while (getline(paidup_mult_streamed, paidup_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_paidup = new GMXB_Assumption_Table(parameter_file,
												paidup_mult_table);
							v_paidup_mult.push_back(mult_table_paidup);
						}
					}
					if (election_shock  != "0")
					{

						istringstream election_mult_streamed(election_shock);
						string election_mult_table;
						while (getline(election_mult_streamed, election_mult_table, ';'))
						{
							GMXB_Assumption_Table *mult_table_election = new GMXB_Assumption_Table(parameter_file,
												election_mult_table);
							v_election_mult.push_back(mult_table_election);
						}
					}
					bool load_longevity_table = false;

					if (longevity_shock == "1")
						load_longevity_table = true;

					Scenario_configuration s_c(scenario_file,
												scenario_pass_number,
												index_shock_array,
											    fund_shock_array,
												use_scn_file,
												shock_funds,
												v_lapse_mult, 
											    v_mortality_mult,
												v_paidup_mult,
												v_election_mult,
											    load_longevity_table);

					p_c.add_scenario_configuration(s_c);
				}
				product_configurations.push_back(p_c);
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the run names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}





/*
* This function load all the necessary parameter for the summarization
* summarization_configuration : This sheet contains all the parameter to summarize a run
*/

void load_summarization_configuration(const string& parameter_file, vector<Summary_configuration>& summary_configurations,
									  vector<Product_configuration>& product_configurations,
									  map<string, vector<string>>& map_scenario_names,
									  map<string, vector<string>>& map_index_shock_names)
{
	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string>> map_run_settings;
		map<string, vector<string>> map_summarization_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); // Jiangang		

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		xml_reader.parse_XML_sheet("summarization_configuration", map_summarization_settings);
		string list_of_summarization_to_run = map_run_settings["list_of_summarization_to_run"][0];
		istringstream list_of_summarization_streamed(list_of_summarization_to_run);
		string summarization_name;
		while (getline(list_of_summarization_streamed, summarization_name, ','))
		{
			trimString(summarization_name);
			vector<string> list_of_summarization = map_summarization_settings["summarization_name"];
			
			int number_of_configured_summarization = list_of_summarization.size();
			if (number_of_configured_summarization > 0)
			{
				int sum_nb = 0;
				bool found = false;
				// Check if the summary name exist or not
				for(int summary_nb = 0; summary_nb < number_of_configured_summarization; summary_nb++)
				{
					if (list_of_summarization[summary_nb] == summarization_name)
					{
						sum_nb = summary_nb;
						found = true;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The summary name %s is not found in the summarization_configuration sheet (file %s) ", 
											summarization_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				string write_ehc_format = map_summarization_settings["write_ehc_format"][sum_nb];
				string write_policy_by_policy_format = map_summarization_settings["write_policy_by_policy_format"][sum_nb];
				string write_total_format = map_summarization_settings["write_total_format"][sum_nb];
				string write_scen_by_scen_format     = map_summarization_settings["write_scen_by_scen_format"][sum_nb];

				bool do_ehc_format = false;
				bool do_policy_by_policy_format = false;
				bool do_total_format = false;
				bool do_scen_by_scen_format = false;
				bool do_mso_format=false;

				if (write_total_format == "1")
					do_total_format = true;

				if ((write_policy_by_policy_format == "1")||(write_policy_by_policy_format == "2")||(write_policy_by_policy_format == "3"))
					do_policy_by_policy_format = true;

				if (write_ehc_format == "1")
					do_ehc_format = true;
				if(write_scen_by_scen_format == "1")
					do_scen_by_scen_format = true;

				if (write_policy_by_policy_format == "3")
					do_mso_format=true;
				string policy_by_policy_directory = "";
				string policy_by_policy_file_name = "";

				string total_file_directory = "";
				string total_file_name = "";

				string ehc_directory = "";
				string ehc_file_name = "";

                string mso_file_directory="";
				string mso_file_name="";
				int ehc_scen_base = 0;
				string ehc_sensi_file_directory = "";
				string ehc_sensi_file_name = "";

				string scen_by_scen_file_directory = "";
				string scen_by_scen_file_name = "";

				if (do_total_format)
				{
					total_file_directory = wm.getPath(map_summarization_settings["total_file_directory"][sum_nb]);
					total_file_name = map_summarization_settings["total_file_name"][sum_nb];
				}
				else if (do_policy_by_policy_format)
				{
					policy_by_policy_directory = wm.getPath(map_summarization_settings["policy_by_policy_file_directory"][sum_nb]);;
					policy_by_policy_file_name = map_summarization_settings["policy_by_policy_file_name"][sum_nb];
					if (do_mso_format)
					{
						mso_file_directory=policy_by_policy_directory;
						mso_file_name = "MSO_"+policy_by_policy_file_name;
					}
				}
				else if(do_scen_by_scen_format)
				{
					scen_by_scen_file_directory = wm.getPath(map_summarization_settings["scen_by_scen_file_directory"][sum_nb]);;
					scen_by_scen_file_name      = map_summarization_settings["scen_by_scen_file_name"][sum_nb];
				}
				else if (do_ehc_format)
				{
					ehc_directory = wm.getPath(map_summarization_settings["ehc_file_directory"][sum_nb]);
					ehc_file_name = map_summarization_settings["ehc_file_name"][sum_nb];
					vector<string> ehc_scenario_base_vector = map_summarization_settings["ehc_scenario_base"];
					if (ehc_scenario_base_vector.size() > 0)
					{
						// Get the scenario pass number 
						// on which the EHC values must be calculated
						string ehc_scenario_base = map_summarization_settings["ehc_scenario_base"][sum_nb];
						map<string, vector<string>> ehc_scen_base_settings;
						xml_reader.parse_XML_sheet(ehc_scenario_base, ehc_scen_base_settings);
						ehc_scen_base = atoi(ehc_scen_base_settings["scenario_pass_number"][0].c_str());
					}
					else
					{
						char message[MAX_LENGTH_MESSAGE_EXCEPTION];
						sprintf_s(message, "The ehc_scenario_base parameter in sheet summarization_configuration is empty for %s", summarization_name.c_str());
						throw new GMXBException(message);
					}
					ehc_sensi_file_directory = wm.getPath(map_summarization_settings["ehc_sensi_file_directory"][sum_nb]);
					ehc_sensi_file_name = map_summarization_settings["ehc_sensi_file_name"][sum_nb];
				}
				else
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "Bad configuration of the summary. Must choose either ehc format or total format or policy by policy format");
					throw new GMXBException(message);
				}

				
				// Check if the recalculation parameter 
				// exists in the map

				bool recalc_param_found = false;

				for (map<string, vector<string>>::const_iterator it_map_summarization_settings = map_summarization_settings.begin();
					it_map_summarization_settings != map_summarization_settings.end(); ++it_map_summarization_settings)
				{
					if (it_map_summarization_settings->first == "recalculate_ehc")
					{
						if (map_summarization_settings["recalculate_ehc"][sum_nb] == "1")
							recalc_param_found = true;
						break;
					}
				}

				 


				Summary_configuration sm_configuration(do_ehc_format, ehc_directory, ehc_file_name,
					do_policy_by_policy_format, policy_by_policy_directory, policy_by_policy_file_name,
					do_scen_by_scen_format, scen_by_scen_file_directory, scen_by_scen_file_name,
					do_total_format, total_file_directory, total_file_name, ehc_scen_base, ehc_sensi_file_directory
					, ehc_sensi_file_name, recalc_param_found,do_mso_format, mso_file_directory, mso_file_name);

				string list_of_runs_to_summarize = map_summarization_settings["list_of_runs_to_summarize"][sum_nb];

				istringstream list_of_runs_streamed(list_of_runs_to_summarize);

				string run_name;
				while (getline(list_of_runs_streamed, run_name, ','))
				{
					trimString(run_name);
					// Search the run name in the vector of configurations
					int number_of_ran_products = product_configurations.size();
					bool run_found = false;
					int run_position = 0;
					for(int product_ran_nb = 0; product_ran_nb < number_of_ran_products; product_ran_nb++)
					{
						Product_configuration run_product = product_configurations[product_ran_nb];
						if (run_product.get_run_name() == run_name)
						{
							run_found = true;
							run_position = product_ran_nb;
							break;
						}
					}
					if (!run_found)
					{
						char message[MAX_LENGTH_MESSAGE_EXCEPTION];
						sprintf_s(message, "The run name %s is not found in the list_of_products_to_run (runs_configuration sheet) ", 
												run_name.c_str());
						throw new GMXBException(message);
					}
					sm_configuration.add_product_configuration(product_configurations[run_position]);
				}
				summary_configurations.push_back(sm_configuration);
				// get the scenario names as well as the 
				// index shock name
				xml_reader.parse_XML_sheet("scenario_names", map_scenario_names);
				xml_reader.parse_XML_sheet("index_shock_names", map_index_shock_names);
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the summarization names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}

/*
* This function load all the necessary parameter for the summarization of the Hedge effectiveness
* summarization_configuration : This sheet contains all the parameter to summarize a run
*/

void load_summarization_configuration_HE(const string& parameter_file, vector<Summary_configuration>& summary_configurations,
									  vector<Product_configuration>& product_configurations_out,
									  vector<Product_configuration>& product_configurations_in)
{
	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string>> map_run_settings;
		map<string, vector<string>> map_summarization_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); // Jiangang		

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		xml_reader.parse_XML_sheet("summarization_configuration", map_summarization_settings);
		string list_of_summarization_to_run = map_run_settings["list_of_summarization_to_run"][0];
		istringstream list_of_summarization_streamed(list_of_summarization_to_run);
		string summarization_name;
		while (getline(list_of_summarization_streamed, summarization_name, ','))
		{
			trimString(summarization_name);
			vector<string> list_of_summarization = map_summarization_settings["summarization_name"];
			
			int number_of_configured_summarization = list_of_summarization.size();
			if (number_of_configured_summarization > 0)
			{
				int sum_nb = 0;
				bool found = false;
				// Check if the summary name exist or not
				for(int summary_nb = 0; summary_nb < number_of_configured_summarization; summary_nb++)
				{
					if (list_of_summarization[summary_nb] == summarization_name)
					{
						sum_nb = summary_nb;
						found = true;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The summary name %s is not found in the summarization_configuration sheet (file %s) ", 
											summarization_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				string summary_file_path = wm.getPath(map_summarization_settings["HE_summarise_file_path"][sum_nb]);
				string summary_file_name = map_summarization_settings["HE_summarise_file_name"][sum_nb];

				Summary_configuration sm_configuration(summary_file_path, summary_file_name);

				string list_of_runs_to_summarize = map_summarization_settings["list_of_runs_to_summarize"][sum_nb];

				istringstream list_of_runs_streamed(list_of_runs_to_summarize);

				string run_name;

				while (getline(list_of_runs_streamed, run_name, ','))
				{
					trimString(run_name);
					// Search the run name in the vector of configurations
					int number_of_ran_products = product_configurations_out.size();
					bool run_out_found = false;
					int run_position_out = 0;
					int run_position_in = 0;
					for(int product_ran_nb = 0; product_ran_nb < number_of_ran_products; product_ran_nb++)
					{
						Product_configuration run_product = product_configurations_out[product_ran_nb];
						if (run_product.get_run_name() == run_name)
						{
							run_out_found = true;
							run_position_out = product_ran_nb;

							// Try to find the product configuration in
							bool run_in_found = false;
							for (unsigned int prod_conf_nb_in = 0; prod_conf_nb_in < product_configurations_in.size(); 
								prod_conf_nb_in++)
							{
								Product_configuration run_product_in = product_configurations_in[prod_conf_nb_in];
								if (run_product_in.get_prod_code_key() == run_product.get_prod_code_key())
								{
									run_in_found = true;
									run_position_in = prod_conf_nb_in;
									break;
								}
							}
							if (!run_in_found)
							{
								char message[MAX_LENGTH_MESSAGE_EXCEPTION];
								sprintf_s(message, "Summary Hedge effectiveness The prod code key %s is not found in the list of product in  ", 
												run_product.get_prod_code_key().c_str());
								throw new GMXBException(message);
							}
							break;
						}
					}
					if (!run_out_found)
					{
						char message[MAX_LENGTH_MESSAGE_EXCEPTION];
						sprintf_s(message, "The run name out %s is not found in the list_of_products_to_run (runs_configuration sheet) ", 
												run_name.c_str());
						throw new GMXBException(message);
					}
					sm_configuration.add_product_configuration_out(product_configurations_out[run_position_out]);
					sm_configuration.add_product_configuration_in(product_configurations_in[run_position_in]);
				}
				summary_configurations.push_back(sm_configuration);
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the summarization names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}


/*
* This function load all the necessary parameter for the stat inforce 
* stat_inforce : This sheet contains all the parameter to calculate statistics about the inforce
*/
void load_statinforce_configuration(const string& parameter_file, 
									vector<Stat_Inforce_Configuration>& stat_inforce_configurations)
{
	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string>> map_run_settings;
		map<string, vector<string>> map_statinforce_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards"); 

		// Load the "stat_inforce" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		xml_reader.parse_XML_sheet("stat_inforce", map_statinforce_settings);
		string list_of_statinforce_to_run = map_run_settings["list_of_stat_inforce_to_run"][0];
		istringstream list_of_statinforce_streamed(list_of_statinforce_to_run);
		string statinforce_name;
		while (getline(list_of_statinforce_streamed, statinforce_name, ','))
		{
			trimString(statinforce_name);
			vector<string> list_of_statinforce = map_statinforce_settings["stat_inforce_names"];
			
			int number_of_configured_statinforce = list_of_statinforce.size();
			if (number_of_configured_statinforce > 0)
			{
				int stat_nb = 0;
				bool found = false;
				// Check if the stat inforce name exist or not
				for(int statinforce_nb = 0; statinforce_nb < number_of_configured_statinforce; statinforce_nb++)
				{
					if (list_of_statinforce[statinforce_nb] == statinforce_name)
					{
						stat_nb = statinforce_nb;
						found = true;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The statinforce name %s is not found in the stat_inforce sheet (file %s) ", 
											statinforce_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				string inforce_file_name = wm.getPath(map_statinforce_settings["inforce_file_name"][stat_nb]);
				string product_code_key_names = map_statinforce_settings["product_code_key_names"][stat_nb];
				string gmxb_type_2 = map_statinforce_settings["gmxb_type2"][stat_nb];
				string stat_inforce_criteria = map_statinforce_settings["stat_inforce_criteria"][stat_nb];
				string realized_rrc_ehc_prem = map_statinforce_settings["realized_rrc_ehc_prem"][stat_nb];
				string output_directory = wm.getPath(map_statinforce_settings["output_directory"][stat_nb]);
				string stat_inforce_file_name = map_statinforce_settings["stat_inforce_file_name"][stat_nb];
				string stat_fund_T_file_name = map_statinforce_settings["stat_fund_T_file_name"][stat_nb];
				string stat_fund_A_file_name = map_statinforce_settings["stat_fund_A_file_name"][stat_nb];
				string do_compare_file = map_statinforce_settings["compare_files"][stat_nb];
				string do_recalculate_ehc = map_statinforce_settings["recalculate_ehc"][stat_nb];
				string reference_file = wm.getPath(map_statinforce_settings["reference_file"][stat_nb]);

				bool compare_files = false;
				bool recalculate_ehc = false;

				if (do_compare_file == "1")
					compare_files = true;

				if (do_recalculate_ehc == "1")
					recalculate_ehc = true;



				Stat_Inforce_Configuration stat_inforce_config(statinforce_name, inforce_file_name, gmxb_type_2,
												stat_inforce_criteria, realized_rrc_ehc_prem, output_directory, 
												stat_inforce_file_name,stat_fund_A_file_name,
												stat_fund_T_file_name, compare_files, reference_file, 
												recalculate_ehc);

				// Parse the prod code key line
				istringstream list_of_prode_cod_keys_streamed(product_code_key_names);
				string pCK;

				while (getline(list_of_prode_cod_keys_streamed, pCK, ','))
				{
					stat_inforce_config.add_prod_code_key(pCK);
				}

				istringstream list_of_gmxb_type_streamed(gmxb_type_2);
				string gmxb_type;

				while (getline(list_of_gmxb_type_streamed, gmxb_type, ','))
				{
					stat_inforce_config.add_gmxb_type(gmxb_type);
				}

				stat_inforce_configurations.push_back(stat_inforce_config);
			}
			else
			{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the stat inforce names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}


int price_file_mode(string& parameter_file, ofstream& log_strm, int tot_nb_workers, int w_id, string& s)//double alpha, double sigma)
{
	try 
	{
		vector<Product_configuration> product_configurations;
		string trace_log_pth;
		
		log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;
	
		double alpha, sigma;
		string s_alpha, s_sigma;
		int virg=0;
		for(int i=0;i<s.size();i++){
			if(s[i]==',') virg++;
			else if(virg==0)
				s_alpha.push_back(s[i]);
			else{
				s_sigma.push_back(s[i]);	
			}
		}
		
		alpha=atof(s_alpha.c_str());
		sigma=atof(s_sigma.c_str());

		load_run_configuration(parameter_file, product_configurations, trace_log_pth, true);
		back_ground bg(product_configurations, tot_nb_workers, w_id, trace_log_pth, alpha, sigma);


		return 1;
	}	
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			cout << "Error from dll : " << e->get_message() << endl;
	
	}
	return 0;
}

/*
* Pricing in mode Risk Appetite
*/
int price_RA(string& parameter_file, ofstream& log_strm, int tot_nb_workers, int w_id, string &s)
{
	try 
	{
		vector<Product_configuration> product_configurations;
		string trace_log_pth;

		load_run_configuration(parameter_file, product_configurations, trace_log_pth, true);
		back_ground bg(product_configurations, tot_nb_workers, w_id, trace_log_pth);

		return 1;
	}	
	catch(GMXBException *e)
	{
		cout << "Error from dll : " << e->get_message() << endl;	
		log_strm << "Error from dll : " << e->get_message() << endl;
		delete e;
	}
	return 0;
}
int __cdecl summarize(string& parameter_file, ofstream& log_strm, int nb_workers, int w_id, string& s)
{
	
	try 
	{
		vector<Product_configuration> product_configurations;
		vector<Summary_configuration> summary_configurations;
		map<string, vector<string> > map_scenario_names;
		map<string, vector<string> > map_index_shock_names;
		string trace_log_pth;
		back_ground bg;
		int nb_workers_used;

		log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;
		log_strm << "begin summarize" << endl;

		load_run_configuration(parameter_file, product_configurations, trace_log_pth, false);

		log_strm << "end load_run_configuration summarize" << endl;
		
		load_summarization_configuration(parameter_file, summary_configurations, product_configurations, map_scenario_names, map_index_shock_names);

		log_strm << "end load_summarization_configuration" << endl;

		nb_workers_used=atoi(s.c_str());
		bg.summarize_results(summary_configurations,
			nb_workers_used,
			map_scenario_names,
			map_index_shock_names,
			NULL);  // Last parameter is for Dispatch manager

		log_strm << "end bg.summarize_result" << endl;
		
		return 1;

	}	
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			cout << "Error from dll : " << e->get_message() << endl;
			delete e;
	}
	return 0;
}



int __cdecl summarize_esg(string& config_Projection, ofstream& log_strm, int nb_workers, int w_id, string& s)
{
	try 
	{
		vector<Product_configuration> product_configurations;
		vector<Summary_configuration> summary_configurations;
		map<string, vector<string> >  map_scenario_names;
		map<string, vector<string> >  map_index_shock_names;
		string trace_log_pth;
		back_ground bg;
		int nb_workers_used;
		log_strm << endl <<"Version " << DLL_VERSION << " of the DLL " << endl;
	    log_strm << endl << "Begin Summarize" << endl;
        
		load_run_configuration_esg(config_Projection,
			                       product_configurations,
								   trace_log_pth,
								   false);
		log_strm << "    Load_run_configuration summarize ended!" << endl;

		//! Dispatch_Manager
		Dispatch_Manager dispatch_manager(product_configurations, config_Projection);

		load_summarization_configuration(config_Projection, 
			                             summary_configurations,
										 product_configurations, 
										 map_scenario_names,
										 map_index_shock_names);
		log_strm << "    Load_summarization_configuration ended!" << endl; 

		nb_workers_used=atoi(s.c_str());
		bg.summarize_results(summary_configurations,
							 nb_workers_used,
							 map_scenario_names,
							 map_index_shock_names,
							 &dispatch_manager);   
		
		log_strm << "bg.summarize_result ended succefully!" << endl;
		
		return 1;
	}	
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			delete e;
	}


	return 0;
}

int __cdecl summarize_RA(string& parameter_file, int nb_workers, ofstream& log_strm, int idWorker, string &s)
{

	try 
	{
		vector<Product_configuration> product_configurations;
		vector<Summary_configuration> summary_configurations;
		map<string, vector<string> > map_scenario_names;
		map<string, vector<string> > map_index_shock_names;
		string trace_log_pth;
		back_ground bg;
       
		log_strm << "begin summarize RA" << endl;

		load_run_configuration(parameter_file, product_configurations, trace_log_pth, false);
		

        for(int i=0;i<product_configurations.size();i++)
		{
			GMXBParameters assump=GMXBParameters(product_configurations[i].get_config_file().c_str(), "assump");
			if (assump.search("risk_appetite")=="Y")
			product_configurations[i].RA_set_inforce_name();
        }

		log_strm << "end load_run_configuration summarize RA" << endl;
		
		load_summarization_configuration(parameter_file, summary_configurations, product_configurations, map_scenario_names, map_index_shock_names);
        
        for(int i=0;i<summary_configurations.size();i++)
		{
			GMXBParameters assump=GMXBParameters(product_configurations[i].get_config_file().c_str(), "assump");
			if (assump.search("risk_appetite")=="Y")
			summary_configurations[i].RA_reset();
		}
		
		log_strm << "end load_summarization_configuration RA" << endl;

		bg.summarize_results(summary_configurations,
			nb_workers,
			map_scenario_names,
			map_index_shock_names,
			NULL);  // Last parameter is for Dispatch manager

		log_strm << "end bg.summarize_result" << endl;
		
		return 1;

	}	
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			delete e;
	}
	return 0;
}

void fill_vector_from_file(string file_name , vector<vector<string>>& v)
{
	ifstream file_op(file_name.c_str() , ios::in);
	if (file_op)
	{
		string row;
		while(!file_op.eof())
		{
			getline(file_op, row);
			vector<string> r;
			if (row.length() > 0)
			{
				istringstream row_streamed(row);
				string element;
				while (getline(row_streamed, element, ',') )
				{
					r.push_back(element);
				}
				v.push_back(r);
			}
		}
	}
	else
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", file_name.c_str());
		throw new GMXBException(message);	
	}
}


void compare_files(string ref_file, string f_to_compare, string ot_result_file, ofstream& log_strm
				   , double test_tolerance)
{
	vector<vector<string>> reference_vector;
	vector<vector<string>> file_to_vector;
	vector<vector<double>> output_vector;

	fill_vector_from_file(ref_file, reference_vector);
	fill_vector_from_file(f_to_compare, file_to_vector);

	int ref_nb_rows = reference_vector.size();
	int f_to_vector_nb_rows = file_to_vector.size();
	int ref_nb_columns = reference_vector[0].size();
	int f_to_vector_nb_columns = file_to_vector[0].size();

	// Check the row number 
	if (ref_nb_rows != f_to_vector_nb_rows)
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The number of rows in %s is different from the number of rows in %s", ref_file.c_str(), f_to_compare.c_str());
		throw new GMXBException(message);		
	}
	// Check the column number
	if (ref_nb_columns != f_to_vector_nb_columns)
	{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The number of columns in %s is different from the number of columns in %s", ref_file.c_str(), f_to_compare.c_str());
		throw new GMXBException(message);			
	}
	// Fill the output vector and check with the passed test 
	// tolerance
	bool test_OK = true;
	for (int i = 0 ; i < ref_nb_rows ; i++ )
	{
		vector<double> row;
		for (int j = 0; j < ref_nb_columns; j++)
		{
			double val = atof(reference_vector[i][j].c_str()) - atof(file_to_vector[i][j].c_str());
			if (fabs(val) > test_tolerance)
					test_OK = false;
			row.push_back(val);
		}
		output_vector.push_back(row);
	}

	if (!test_OK)
	{
		log_strm << "Comparaison " << ref_file.c_str() << " and " << f_to_compare.c_str() << " NOK " << endl;
	}
	else
	{
		log_strm << "Comparaison " << ref_file.c_str() << " and " << f_to_compare.c_str() << " OK " << endl;
	}
	// Write the output file	
	ofstream output(ot_result_file.c_str());
	for (int i = 0 ; i < ref_nb_rows ; i++ )
	{
		for (int j = 0; j < ref_nb_columns; j++)
		{
			output << output_vector[i][j] << ",";
		}
		output << endl;
	}
}

int non_reg_tests(string& parameter_file, ofstream& log_strm, int nb_workers, int w_id, string& s) 
{
	try 
	{
		map<string, vector<string>> map_non_reg_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 
		xml_reader.parse_XML_sheet("non-reg-conf", map_non_reg_settings);
		double test_tolerance = atof(map_non_reg_settings["TEST_TOLERANCE"][0].c_str());
		int map_size = map_non_reg_settings.size();
		for (int i = 2; i < map_size; i++)
		{
			char label[100];
			sprintf(label, "%s_%d", "COMPARAISON", i-1);
			vector<string> comparaison_vector = map_non_reg_settings[label];
			string reference_file = wm.getPath(comparaison_vector[REFERENCE_FILE]);
			string file_to_compare = wm.getPath(comparaison_vector[FILE_TO_COMPARE]);
			string output_result_file = wm.getPath(comparaison_vector[OUTPUT_RESULTS]);
			compare_files(reference_file, file_to_compare, output_result_file, log_strm, test_tolerance);

		}
	}
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
	}

	return 0;
}

int price_with_different_seed( string& parameter_file, ofstream& log_strm, int tot_nb_workers, int w_id, string& s)//double alpha, double sigma )
{
	try 
	{
		vector<Product_configuration> product_configurations;
		string trace_log_pth;
		load_run_configuration(parameter_file, product_configurations, trace_log_pth, false);
		
		double alpha, sigma;
		string axagen_config_file;
		string s_alpha, s_sigma;
		int virg=0;
		for(int i=0;i<s.size();i++){
			if(s[i]==',') virg++;
			else if(virg==0)
				s_alpha.push_back(s[i]);
			else if(virg==1)
				s_sigma.push_back(s[i]);
			else{
				axagen_config_file.push_back(s[i]);	
			}
		}
		
		alpha=atof(s_alpha.c_str());
		sigma=atof(s_sigma.c_str());
		back_ground bg(product_configurations,  tot_nb_workers,  w_id,  trace_log_pth, axagen_config_file, alpha, sigma);

		log_strm << " Projections with different seed ended correctly " << endl;
		return 1;
	}	
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
	}
	return 0;
}


int check_assumptions(string& parameter_file, ofstream& log_strm, int nb_workers, int w_id, string& s)// bool use_scenario_file)
{
	try
	{
		log_strm << "Checking the assumptions" << endl;
		File_Manager file_mgr;
		vector<Product_configuration> product_configurations;
		vector<Scenario_configuration> scenario_configurations;
		string trace_log_pth;
		bool use_scenario_file= (bool)atoi(s.c_str());
		// Check the projection
		load_run_configuration(parameter_file, product_configurations, trace_log_pth, use_scenario_file);
		int products_size = product_configurations.size();
		for (int i = 0; i < products_size; i++)
		{
			Product_configuration product = product_configurations[i];
			// Check the inforce file name
			file_mgr.is_file_path_valid(product.get_model_point_file());
			// Check the assumption file name
			file_mgr.is_file_path_valid(product.get_config_file());
			// Check the result directory
			file_mgr.is_directory_path_valid(product.get_result_file_path());
			// Check the debug directory
			if (product.get_generate_debug_file_indic())
			{
				file_mgr.is_directory_path_valid(product.get_debug_file_path());
			}
			if (product.is_projection_by_fund())
			{
				// Check the parameters files
				file_mgr.is_file_path_valid(product.get_fund_split_file());
				file_mgr.is_file_path_valid(product.get_mgmt_fee_file());
				file_mgr.is_file_path_valid(product.get_fund_valo_file());
			}
			
			if (use_scenario_file)
			{
				// Check the scenario files
				vector<Scenario_configuration> scenario_configurations = product.get_scenario_list();
				int scen_list_size = scenario_configurations.size();
				for(int scen_list = 0; scen_list < scen_list_size; scen_list ++)
				{
					Scenario_configuration scen_config = scenario_configurations[scen_list];
					file_mgr.is_file_path_valid(scen_config.get_scenario_file_name());
				}
			}
		}
		// Check the summarize
		vector<Summary_configuration> summary_configurations;
		map<string, vector<string> > map_scenario_names;
		map<string, vector<string> > map_index_shock_names;

		load_summarization_configuration(parameter_file, summary_configurations, product_configurations, 
					map_scenario_names, map_index_shock_names);

		int summary_size = summary_configurations.size();

		for (int i =0; i < summary_size; i++)
		{
			Summary_configuration summary_config = summary_configurations[i];

			if (summary_config.get_ehc_format_indicator())
			{
				file_mgr.is_directory_path_valid(summary_config.get_ehc_file_directory());
				file_mgr.is_directory_path_valid(summary_config.get_ehc_sensi_file_directory());
			}
			if (summary_config.get_policy_by_policy_indicator())
				file_mgr.is_directory_path_valid(summary_config.get_policy_by_policy_file_directory());
			if (summary_config.get_scen_by_scen_indicator())
				file_mgr.is_directory_path_valid(summary_config.get_scen_by_scen_file_directory());
			if (summary_config.get_total_file_indicator())
				file_mgr.is_directory_path_valid(summary_config.get_total_file_directory());
		}

		return 1;
	}
	catch(GMXBException *e)
	{
		cout << "Error from dll : " << e->get_message() << endl;
		log_strm << "Error from dll : " << e->get_message() << endl;
		delete e;
	}
	return 0;
}

int delete_intermediate_files(string& parameter_file, ofstream& log_strm, int nb_workers, int w_id, string& s)         
{
	try 
	{
		vector<Product_configuration> product_configurations;
		vector<Scenario_configuration> scenario_configurations;
		map<string, vector<string> > map_scenario_names;
		map<string, vector<string> > map_index_shock_names;
		string trace_log_pth;
		int nb_workers_used;
		bool use_scn_file = false;
		nb_workers_used=atoi(s.c_str());
		log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;

		log_strm << "deleting files " << endl;
		//load_run_configuration(parameter_file, product_configurations, trace_log_pth, use_scn_file);
		load_run_configuration_esg(parameter_file,product_configurations,trace_log_pth,use_scn_file);
		int products_size = product_configurations.size();
		for (int i = 0; i < products_size; i++)
		{
			Product_configuration product = product_configurations[i];
			scenario_configurations = product.get_scenario_list();
			int scen_list_size = scenario_configurations.size();
			
			for(int scen_list = 0; scen_list < scen_list_size; scen_list ++)
			{
				Scenario_configuration scen_conf = scenario_configurations[scen_list];

				for (int worker_id = 1; worker_id <= nb_workers_used; worker_id++)
				{
					int shock_size = scen_conf.get_index_shock_array().size();
					
					for (int sh_nu = 0; sh_nu < int(scen_conf.get_fund_shock_array().size()); sh_nu++)
					{	
						int shock_numb = get_shock_number(scen_conf.get_fund_shock_array(), sh_nu, MAX_DELTA_SHOCKS_PER_INDEX, scen_conf.get_fund_shock_array()[0].size());
						char file_name[MAX_LENGTH_FILE_NAME];

						if (product.get_write_valo_policy_by_policy())
							sprintf(file_name, "%s%s_fund_%d_%d_%d.csv", product.get_result_file_path().c_str(), product.get_run_name().c_str(), 
								scen_conf.get_scenario_pass_number(), shock_numb, worker_id);
						else
							sprintf(file_name, "%s%s_total_fund_%d_%d_%d.csv", product.get_result_file_path().c_str(), product.get_run_name().c_str(), 
								scen_conf.get_scenario_pass_number(), shock_numb, worker_id);

						remove(file_name);						
					}
				

					for(int sh_num = 0; sh_num < int(scen_conf.get_index_shock_array().size()); sh_num++)
					{
						int shock_number = get_shock_number(scen_conf.get_index_shock_array(), sh_num, MAX_DELTA_SHOCKS_PER_INDEX, MAXIMUM_NUMBER_OF_INDEXES);
						char file_name[MAX_LENGTH_FILE_NAME];
						//andrei-----
						int bucket_id= scen_conf.get_bucket_id();
						
						if (bucket_id== -1)
						{
						if (product.get_write_valo_policy_by_policy())
							sprintf(file_name, "%s%s_index_%d_%d_%d.csv", product.get_result_file_path().c_str(), product.get_run_name().c_str(), 
								scen_conf.get_scenario_pass_number(), shock_number, worker_id);
						else
							sprintf(file_name, "%s%s_total_index_%d_%d_%d.csv", product.get_result_file_path().c_str(), product.get_run_name().c_str(), 
								scen_conf.get_scenario_pass_number(), shock_number, worker_id);
						}
						else
						{
							if (product.get_write_valo_policy_by_policy())
								sprintf(file_name, "%s%s_index_%d_%d_%d_%d.csv", product.get_result_file_path().c_str(), product.get_run_name().c_str(), 
									scen_conf.get_scenario_pass_number(), bucket_id, shock_number, worker_id);
							else
								sprintf(file_name, "%s%s_total_index_%d_%d_%d_%d.csv", product.get_result_file_path().c_str(), product.get_run_name().c_str(), 
									scen_conf.get_scenario_pass_number(),bucket_id, shock_number, worker_id);
						}
						remove(file_name);
					}
				}
			}
		}
		log_strm << "deleting files ended correctly" << endl;
		return 1;
	}	

	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			delete e;
	}
	return 0;
}

int copy_assumptions(string& parameter_file, ofstream& log_strm, int nb_workers, int w_id, string& s) 
{
	try 
	{
		vector<Product_configuration> product_configurations;
		vector<Scenario_configuration> scenario_configurations;
		string trace_log_pth;
		File_Manager file_mgr;
		// Load the assumption
		load_run_configuration(parameter_file, product_configurations, trace_log_pth, false);
		map<string, vector<string> > map_run_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);

		// Copy the run configuration it_self

		string full_run_conf_file_name = parameter_file;

		int products_size = product_configurations.size();
		for (int i = 0; i < products_size; i++)
		{
			Product_configuration product = product_configurations[i];

			string assumption_output_directory = product.get_assumption_output_directory();

			file_mgr.is_directory_path_valid(assumption_output_directory);

			string output_run_conf_file_name = assumption_output_directory +  full_run_conf_file_name.substr(full_run_conf_file_name.find_last_of("/\\"),full_run_conf_file_name.length());			
			CopyFile(full_run_conf_file_name.c_str(), output_run_conf_file_name.c_str(), false);

			// Copy the inforce file
			string full_inforce_file_name = product.get_model_point_file();
			string output_inforce_file_name = assumption_output_directory +  full_inforce_file_name.substr(full_inforce_file_name.find_last_of("/\\"),full_inforce_file_name.length());			
			CopyFile(full_inforce_file_name.c_str(), output_inforce_file_name.c_str(), false);
			
			// Copy the assumptions file
			string full_assumption_file_name = product.get_config_file();
			string output_assumption_file_name = assumption_output_directory + full_assumption_file_name.substr(full_assumption_file_name.find_last_of("/\\"),full_assumption_file_name.length());
		
			CopyFile(full_assumption_file_name.c_str(), output_assumption_file_name.c_str(), false);
		}
		return 1;
	}
	catch(GMXBException * e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			delete e;
	}


	return 0;
}

/*
 *	Mode 0: Use existing scenario file, DLL only does the projection part
*/
int run_HA_file_mode(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s)//double alpha, double sigma)
{
	try
	{
		WildcardManager wm( config, "wildcards" );
		GMXBParameters parameter_main( config, "main_application" );	
		string config_projection = wm.getPath(parameter_main.search("Projection_configuration"));

		ostringstream sgstr;
		sgstr<<nbWorker;

		int p = price_file_mode(config_projection, log_strm, nbWorker, idWorker, s);//alpha, sigma);
		int result = summarize(config_projection, log_strm, 1, 1, sgstr.str());

		if (p == 0 || result == 0)
			return 0;
		else
			return 1;
	}

	catch(GMXBException *g)
	{
		cout <<g->get_message() << endl;
		getchar();
	}
	return 0;
}

/*
* Mode 2: DLL only does the calibration task
*/ 
int calibration_standalone(string& config_calib, ofstream& log_strm, int nbWorker, int idWorker, string& s)
{
	try
	{
		 log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;
		 log_strm << "config_calib = " << config_calib << endl;

		 double a,sigma;
		 double* zc = new double[1200];


		 ifstream conf_file(config_calib.c_str(), ios::in);
		 if (conf_file)
		 { 
			InterfaceCalibration iCalib(config_calib);
			iCalib.Calibrate(a,sigma,zc, 0, -1, idWorker);
		 }
		 else
		 {
			 char message[MAX_LENGTH_MESSAGE_EXCEPTION];
			sprintf_s(message, "The file %s doesn't exist", config_calib.c_str());
			throw new GMXBException(message);		 
		 }
	
		 delete[] zc;
		 //delete[] calib_fin;
		 return 1;
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll : " << e->get_message() << endl;
	
	}
	return 0;
}

/*
* Mode 2: DLL only does the calibration task
*/ 
int run_calibration_standalone(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s)
{
	try
	{
		 WildcardManager wm( config, "wildcards" );
		 GMXBParameters ESGparameter( config, "main_application" );	
		 string config_calib = wm.getPath(ESGparameter.search("Esg_configuration"));

		 return calibration_standalone(config_calib, log_strm, nbWorker, idWorker, s);
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll : " << e->get_message() << endl;
		cout << "Error from dll : " << e->get_message() << endl;
	}
	return 0;
}


int esg_standalone(string& config_ESG, ofstream& log_strm, int nb_of_workers, int worker_id, string& s)
{

		 log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;
	


		 double a, sigma;

		 //ifstream conf_file1(config_calib.c_str(), ios::in);
		 ifstream conf_file1(config_ESG.c_str(), ios::in);
		 if (conf_file1)
		 { 
			InterfaceCalibration iCalib(config_ESG);
			InterfaceEsg iEsg(config_ESG);
			double*** va_scen_0;
			bool if_calib = iEsg.calibration;
			va_scen_0 = iEsg.Gen(iCalib, a, sigma, 0, if_calib,  -1, worker_id);
		 }

		 const char* ESG = config_ESG.c_str();
		 int n = 0;
		 while(ESG[n]!='\0'){
			n++;
		 }
		 char* ESG_fin = new char[n-3];
		 for(int i=0;i<n-4;i++){
			 ESG_fin[i]=ESG[i];
		 }
		 ESG_fin[n-4]='\0';
		 string config_ESG2(ESG_fin);
		
		 for(int scenario_pass_number=1; scenario_pass_number<=1000; scenario_pass_number++){
			 stringstream ss;
			 ss << scenario_pass_number;
			 
			 ifstream conf_file_1((config_ESG2 + "_" + ss.str() + ".xml").c_str(), ios::in);
			 if (conf_file_1)
			 { 
				 double*** va_scen;
				 InterfaceCalibration iCalib(config_ESG2 + "_" + ss.str() + ".xml");
				 InterfaceEsg iEsg(config_ESG2 + "_" + ss.str() + ".xml");

				 bool if_calib_2 = iEsg.calibration;
				 va_scen = iEsg.Gen(iCalib, a, sigma, scenario_pass_number, if_calib_2,  -1, worker_id);
			 }
		 }

		 delete[] ESG_fin;

		 return 1;
}

/*
* Mode 3: DLL do calibration (it is an option, can be deactived in config) + and generates scenario
*/
int run_esg_standalone(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string & s)
{
	
	int esg; 
		
	WildcardManager wm(config, "wildcards");
	GMXBParameters parameter_main( config, "main_application" );	
	string config_esg = wm.getPath(parameter_main.search("Esg_configuration"));
		
		 esg = esg_standalone(config_esg, log_strm, nb_of_workers, worker_id, s);
		 if (esg == 0)
			return 0;
		 
		 return 1;
	}

int esg_projection(string& config_projection, ofstream& log_strm, int nb_of_workers, int worker_id, string& s)
{

	log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;

	double begin = clock();

	// The first worker copy the assumptions
	if (worker_id == 1)
			copy_assumptions(config_projection, log_strm, 1, worker_id, s);


 	 try 
		{
			vector<Product_configuration> product_configurations;
			string trace_log_pth;

			load_run_configuration_esg(config_projection,
				product_configurations,
				trace_log_pth,
				false);

			Dispatch_Manager dispatch_manager(product_configurations, config_projection);

			back_ground bg(product_configurations,
						   trace_log_pth,
				           log_strm,
						   nb_of_workers,
						   worker_id,
						   //total_period,
						   dispatch_manager);

				double end = clock();
				log_strm << endl << "Execution time for worker : " << worker_id << " is : "  << end - begin << endl;

			return 1;
		}	
		catch(GMXBException *e)
		{
				log_strm << "Error from dll : " << e->get_message() << endl;
				cout << "Error from dll : " << e->get_message() << endl;
				delete e;
		}

		return 0;
}

/* 
* Mode 4 : DLL does the calibration (it is an option, can be deactived in config) + projection + esg
*/
int run_HA_esg_mode(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s)
{
	 WildcardManager wm(config, "wildcards");
	 GMXBParameters parameter_main(config, "main_application");	
	 string config_projection = wm.getPath(parameter_main.search("Projection_configuration"));

 
		int p = esg_projection(config_projection, log_strm, nb_of_workers, worker_id, s);
 		if (p == 0)
			return 0;
			
		int sm = summarize_esg(config_projection, log_strm, nb_of_workers, worker_id, s);
		if (sm == 0)
			return 0;

	 	return 1;
}

/*
 *	Mode 7: Risk Appetite, Use existing scenario file, DLL only does the projection part
*/
int run_RA_mode(string& config, ofstream& log_strm, int nbWorker, int idWorker, string &s)
{
	try
	{
		WildcardManager wm( config, "wildcards" );
		GMXBParameters parameter_main( config, "main_application" );	
		string config_projection = wm.getPath(parameter_main.search("Projection_configuration"));

		int p = price_RA(config_projection, log_strm, nbWorker, idWorker, s);
		int result = summarize_RA(config_projection, nbWorker, log_strm, idWorker,s);
		
		
	    _CrtDumpMemoryLeaks();

		if (p == 0 || result == 0)
			return 0;
		else
			return 1;
	}

	catch(GMXBException *g)
	{
		cout <<g->get_message() << endl;
		getchar();
	}
	return 0;
}
int stat_inforce(string& parameter_file, ofstream& log_strm, int nb_workers, int w_id, string& s)
{

	try 
	{
		log_strm << endl << "Version " << DLL_VERSION << " of the DLL " << endl;
	    log_strm << endl << "Begin Stat inforce " << endl;

		vector<Stat_Inforce_Configuration> v_stat_inforce;

		log_strm << endl << "Load Stat inforce " << endl;
		
		load_statinforce_configuration(parameter_file, v_stat_inforce);
		
		back_ground bg;
		
		log_strm << endl << "Generate Statistics " << endl;
		
		bg.generate_stat_inforces(v_stat_inforce);
		
		log_strm << endl << "End Stat inforce " << endl;
		return 1;
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll (Stat inforce) : " << e->get_message() << endl;
		cout << "Error from dll (Stat inforce) : " << e->get_message() << endl;
	}

	return 0;
}




void load_he_configuration(string& projection_file, HE_configuration* he_conf)
{
	map<string, vector<string> > map_HE_configuration;
	GMXBExcelXMLReader xml_reader(projection_file);
	WildcardManager wm(projection_file, "wildcards"); 

	File_Manager f_mgr;
	// Load the "runs_configuration" sheet
	xml_reader.parse_XML_sheet("HE_configuration", map_HE_configuration);

	he_conf->set_size(atoi(map_HE_configuration["size_of_output"][0].c_str()));
	he_conf->set_output_path_file(map_HE_configuration["output_file_path"][0].c_str());
	f_mgr.is_directory_path_valid_2(he_conf->get_output_path_file(), "output_file_path");
	he_conf->set_write_output_file(atoi(map_HE_configuration["generate_output_files"][0].c_str()));
	he_conf->set_inforce_in_path_file(wm.getPath(map_HE_configuration["inforce_inner_file_path"][0]));
	f_mgr.is_directory_path_valid_2(he_conf->get_inforce_in_path_file(),"inforce_inner_file_path");
	he_conf->set_write_inforce_in_file(atoi(map_HE_configuration["generate_inforce_inner_files"][0].c_str()));
	he_conf->set_inforce_out_path_file(wm.getPath(map_HE_configuration["inforce_outer_file_path"][0]));
	f_mgr.is_directory_path_valid_2(he_conf->get_inforce_out_path_file(),"inforce_outer_file_path");
	he_conf->set_write_inforce_out_file(atoi(map_HE_configuration["generate_inforce_outer_files"][0].c_str()));

	he_conf->set_inforce_in_file_name(map_HE_configuration["inforce_inner_file_name"][0].c_str());
	he_conf->set_inforce_out_file_name(map_HE_configuration["inforce_outer_file_name"][0].c_str());
	
	he_conf->set_calibration_file_path(wm.getPath(map_HE_configuration["calibration_file_path"][0]));
	f_mgr.is_directory_path_valid_2(he_conf->get_calibration_file_path(),"calibration_file_path");
	he_conf->set_calibration_file_name(map_HE_configuration["calibration_file_name"][0].c_str());
	
	he_conf->set_inter_result_file_path(wm.getPath(map_HE_configuration["inter_result_file_path"][0]));
	he_conf->set_result_file_path(wm.getPath(map_HE_configuration["result_file_path"][0]));
	f_mgr.is_directory_path_valid_2(he_conf->get_result_file_path(),"result_file_path");
	he_conf->set_result_file_name(map_HE_configuration["result_file_name"][0].c_str());
	he_conf->set_result_inter_file_name(map_HE_configuration["result_inter_file_name"][0].c_str());

	he_conf->set_use_scenario_file_inner(atoi(map_HE_configuration["use_scenario_file_inner"][0].c_str()));

	he_conf->set_output_calibration_parameters(atoi(map_HE_configuration["output_calibration_parameters"][0].c_str()));

	he_conf->set_output_inner_pvs(atoi(map_HE_configuration["output_inner_pvs"][0].c_str()));
	he_conf->set_inner_pvs_file_path(wm.getPath(map_HE_configuration["inner_pvs_file_path"][0]));
	f_mgr.is_directory_path_valid_2(he_conf->get_inner_pvs_file_path(),"inner_pvs_file_path");
	he_conf->set_inner_pvs_file_name(map_HE_configuration["inner_pvs_file_name"][0].c_str());
	string step_write_scenarios_inner=map_HE_configuration["step_write_scenarios_inner"][0].c_str();
	
	istringstream row_streamed;
	row_streamed.str(step_write_scenarios_inner);
	string element;
	vector<int> scenarios_write;
	while(getline(row_streamed, element, ','))
	{
		scenarios_write.push_back(atoi(element.c_str()));
	}

	//int step_scenarios_write[PERIOD];
	for (int i=0;i<PERIOD;i++)
	{
		he_conf->step_scenarios_write[i]=0;
	}
	for (unsigned int i=0;i<scenarios_write.size();i++)
	{
		he_conf->step_scenarios_write[scenarios_write[i]]=1;
	}

	string nb_inforce_in=map_HE_configuration["number_of_inforce_inner_files"][0];
	if (strcmp(nb_inforce_in.c_str(),"Only 1")==0)
		he_conf->set_nb_inforce_inner(0);
	else
		he_conf->set_nb_inforce_inner(1);

	string he_mode=map_HE_configuration["he_mode"][0];
	if (strcmp(he_mode.c_str(),"Hedging")==0)
		he_conf->set_he_mode(0);
	else
		he_conf->set_he_mode(1);

	he_conf->set_shock_size(atoi(map_HE_configuration["shock_size"][0].c_str()));

	map<string, vector<string> > output_table;
	xml_reader.parse_XML_sheet("output", output_table);

	he_conf->init_output(he_conf->get_size(),4);

	for (int i=1; i<=he_conf->get_size();i++)
	{
		for (int j=0; j<4;j++)
		{
			string index;
			index=nb_to_string(i);
			he_conf->set_output(i-1,j,output_table[index][j].c_str());
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////Hedge Effectiveness Part///////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
int InterfacePriceHE( string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s)
{
	try 
	{
			log_strm << "Hedge effectiveness : enter the dll code " << endl;
		   
			//local
			// WildcardManager wm( config, "wildcards" );
			//GMXBParameters HEparameter( config, "main_application" );
			
			//dispatcher
			WildcardManager wm( s, "wildcards" );
			GMXBParameters HEparameter( s, "main_application" );
	
			ofstream logStrm_out( wm.getPath(HEparameter.search("Log_Outer")).c_str() );
			ofstream logStrm_in( wm.getPath(HEparameter.search("Log_Inner")).c_str() );

			string config_projection_out = wm.getPath(HEparameter.search("Projection_Outer"));
			string config_projection_in = wm.getPath(HEparameter.search("Projection_Inner"));

			log_strm << "config_projection_out " << config_projection_out << endl;
			log_strm << "config_projection_in " <<  config_projection_in << endl;
			log_strm << "nbWorker: " <<  nbWorker << endl;
			log_strm << "idWorker: " <<  idWorker << endl;

			vector<Product_configuration> product_configurations_out;

			string trace_log_pth_out, trace_log_pth_in;

			HE_configuration* he_conf = new HE_configuration();

			load_he_configuration(config_projection_out, he_conf);
			//log_strm << "Ali_test_1 " <<  endl;
			load_run_configuration_he_outer(config_projection_out,
				product_configurations_out, 
				trace_log_pth_out, true);
			//log_strm << "Ali_test_2 " <<  endl;
			InterfaceCalibration* iCalib_in=0;
			InterfaceEsg* iEsg_in=0;

			if (he_conf->get_use_scenario_file_inner()==0)
			{
					string config_calib_in = wm.getPath(HEparameter.search("Esg_Inner"));
					iCalib_in= new InterfaceCalibration(config_calib_in);
					string config_ESG_in = wm.getPath(HEparameter.search("Esg_Inner"));
					iEsg_in= new InterfaceEsg(config_ESG_in);
			}

			vector<Product_configuration> product_configurations_in;

			log_strm << "After load_run_configuration_esg  " << endl;

			load_run_configuration_esg(config_projection_in, 
								product_configurations_in, 
								trace_log_pth_in,
								false);

			log_strm << "Hedge effectiveness : enter the back_ground function " << endl;
			back_ground bg(product_configurations_out, product_configurations_in,  
					nbWorker, idWorker, 
					trace_log_pth_out, trace_log_pth_in, 
					*iCalib_in, *iEsg_in,
					he_conf,log_strm);

			delete he_conf;
			
			if (iCalib_in!=0)
				delete iCalib_in;
			if (iEsg_in!=0)
				delete iEsg_in;

			logStrm_out << "Projections ended correctly " << endl;

			return 1;
	}
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			cout << "Error from dll : " << e->get_message() << endl;
	}
	return 0;

}
void merge_multi (const string& out, vector<string>& inputs)
{
	ofstream file (out.c_str(),ios::out);
	string line;
	//ifstream file_0 (inputs[0].c_str());

	for(int i = 0; i < inputs.size(); i++)
	{
		ifstream file_0 (inputs[i].c_str());
		while (!file_0.eof())
		{
			getline(file_0,line);
			if (line != "")
			{
				file<<line;
				file<<"\n";
			}
			else
			{
				/*line = "toto"*/;
			}
		}
		file_0.close();
	}
	//file_0.close();
	file.close();
}
void XML_set(const string& xml_file,const map<string,map<string,string>>& pack)
	{

		const char * ch;
		bool test = true;

		TiXmlDocument doc(xml_file.c_str());
		bool loadOK = doc.LoadFile();
	
		TiXmlHandle doch(&doc);
		TiXmlElement * p_root = doch.FirstChildElement().Element();

		TiXmlHandle h_root(p_root);
		TiXmlElement * p_worksheet;
		
		map<string,map<string,string>>::const_iterator ite;
		map<string,string> temp_map;
		map<string,string>::iterator ito;

		TiXmlElement * p_table;
		TiXmlElement * p_row; 
		TiXmlElement * p_data;
		

		for(ite=pack.begin();ite!=pack.end();ite++)
		{

			p_worksheet = h_root.FirstChild("Worksheet").Element();

			while(p_worksheet && p_worksheet->Attribute("ss:Name")!=ite->first)
					p_worksheet = p_worksheet->NextSiblingElement();
				
			TiXmlHandle h_worksheet(p_worksheet);
			p_table = h_worksheet.FirstChild("Table").Element();
				
			TiXmlHandle h_table(p_table);

			
			temp_map = ite->second;
			for(ito=temp_map.begin();ito!=temp_map.end();ito++)
			{
				p_row = h_table.ChildElement("Row", 0).Element();
				test = true;
				while(p_row && p_row->Value()== string("Row")&& test==true)
				{
					TiXmlHandle h_row(p_row);
					p_data = h_row.ChildElement("Cell",0).FirstChild("Data").Element();
					if(p_data->GetText()==string(ito->first))
					{
						int i =1;
						while ((p_data = h_row.ChildElement("Cell",i).FirstChild("Data").Element()))
						{
							ch = p_data->GetText();
							p_data->FirstChild()->SetValue((string)ito->second);
							/*ch = p_data->GetText();*/
							i++;
						}
						test = false;

					}
					else
					{
						p_row = p_row->NextSiblingElement();
					}				
				}
			}

		}

		doc.SaveFile(xml_file.c_str());

			
	}
void load_he_configuration_aging_policies(string& projection_file, Aging_Policies_configuration* ap_conf)
{
	map<string, vector<string> > map_AP_configuration;
	GMXBExcelXMLReader xml_reader(projection_file);

	// Load the "runs_configuration" sheet
	xml_reader.parse_XML_sheet("AP_configuration", map_AP_configuration);
	
	ap_conf->set_write_inforce_in_file(atoi(map_AP_configuration["generate_inforce_inner_files"][0].c_str()));


	//AP - modification for reading date in run configuration file
	ap_conf->set_bom_date(map_AP_configuration["BOM_date"][0]);
	ap_conf->set_eom_date(map_AP_configuration["EOM_date"][0]);
	ap_conf->set_duration_age_step();
	
	
	
	//ap_conf->set_target_weights_path(map_AP_configuration["target_weights_file_path"][0]);
	//ap_conf->set_current_weights_path(map_AP_configuration["current_weights_file_path"][0]);

	ap_conf->set_lapse_multiplier(map_AP_configuration["lapse_multiplier"][0]);
	ap_conf->set_death_rate_multiplier(map_AP_configuration["death_rate_multiplier"][0]);
	ap_conf->set_charges_multiplier(map_AP_configuration["charges_multiplier"][0]);
	//ap_conf->set_duration_age_step(map_AP_configuration["duration_age_step"][0]);

	ap_conf->set_bom_prod(map_AP_configuration["inforce_bom_prod"][0]);
	ap_conf->set_eom_prod(map_AP_configuration["inforce_eom_prod"][0]);
	ap_conf->set_fund_split_eom(map_AP_configuration["fund_split_eom"][0]);
	ap_conf->set_fund_valo_eom(map_AP_configuration["fund_valo_eom"][0]);
	ap_conf->set_mode(atoi(map_AP_configuration["mode"][0].c_str()));
	ap_conf->set_eom_prod_no_nb(map_AP_configuration["inforce_eom_prod_no_nb"][0]);
	ap_conf->set_eom_model(map_AP_configuration["inforce_eom_model"][0]);
	ap_conf->set_new_business(map_AP_configuration["inforce_prod_new_business"][0]);

	ap_conf->set_temporary_directory(map_AP_configuration["temporary_directory"][0]);
	ap_conf->set_products(map_AP_configuration["products"][0]);

	string nb_inforce_in = map_AP_configuration["number_of_inforce_inner_files"][0];
	if (strcmp(nb_inforce_in.c_str(),"Only 1")== 0)
		ap_conf->set_nb_inforce_inner(0);
	else
		ap_conf->set_nb_inforce_inner(1);

	ap_conf->set_he_mode(1);
}


void set_inforces_via_prod_key(const string& prod_key,
					  const string& valo_adress,const string& split_adress,
					  const string& BOM_file,const string& EOM_file,int mode,
					  const string& temp_bom,const string& temp_perfs,
					  const string& temp_tw,const string& temp_cw,
					  const string& new_business,const string& eom_prod)
{
		map<string,double> valo_file;
		map<string, vector<double>> split_file;
		
		inforces_AP * inforces = new inforces_AP;
		
		inforces->import_valo_file(valo_adress,valo_file);

		inforces->import_split_file(split_adress,split_file);

		inforces->import_BOM(BOM_file);

		inforces->import_EOM(EOM_file);

		inforces->set_BOM(valo_file,split_file);
		
		inforces->get_dll_inputs_via_prod_key(prod_key,temp_bom,temp_perfs,temp_tw,temp_cw,mode);
		
		inforces->get_eom_pack_via_prod_key(prod_key,eom_prod,new_business,mode);

		delete inforces;
}

int __cdecl run_aging_policies( string& config, ofstream& log_strm, int tot_nb_workers, int w_id, string& s)
{
	try 
	{
			log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;

			string config_projection_out = config;

			vector<Product_configuration> product_configurations_out;

			string trace_log_pth_out, trace_log_pth_in;;

			Aging_Policies_configuration* ap_conf = new Aging_Policies_configuration();

			load_he_configuration_aging_policies(config_projection_out, ap_conf);

			load_run_configuration_he_outer(config_projection_out,
				product_configurations_out, 
				trace_log_pth_out, true);

			string prod_key;
			char temp_bom [1000];
			char temp_perfs[1000];
			char temp_tw[1000];
			char temp_cw[1000];
			char temp_new_business[1000];
			char temp_eom_no_nb[1000];
			char temp_eom_model[1000];
			vector<string> eom_model_for_merge;
			vector<string> eom_prod_no_nb_for_merge;
			vector<string> new_business_for_merge;

			
			log_strm<<"\n";

			for (int i = 0; i<ap_conf->get_products().size() ;i++)
			{
				prod_key = ap_conf->get_products()[i];
				sprintf(temp_bom,"%stemp_%s_bom.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());
				sprintf(temp_perfs,"%stemp_%s_perfs.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());
				sprintf(temp_tw,"%stemp_%s_tw.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());
				sprintf(temp_cw,"%stemp_%s_cw.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());
				sprintf(temp_new_business,"%stemp_%s_new_business.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());
				sprintf(temp_eom_no_nb,"%stemp_%s_eom_no_nb.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());
				sprintf(temp_eom_model,"%stemp_%s_eom_model.csv",ap_conf->get_temporary_directory().c_str(),prod_key.c_str());

				log_strm<<"Entering "<<prod_key<<" aging policies setup \n";

				set_inforces_via_prod_key(prod_key,
					ap_conf->get_fund_valo_eom(),
					ap_conf->get_fund_split_eom(),
					ap_conf->get_bom_prod(),
					ap_conf->get_eom_prod(),
					ap_conf->get_mode(),
					temp_bom,
					temp_perfs,
					temp_tw,
					temp_cw,
					temp_new_business,
					temp_eom_no_nb);

				ap_conf->add_temp_pack(temp_bom,temp_perfs,temp_cw,temp_tw,temp_eom_no_nb,temp_new_business,temp_eom_model);

				eom_model_for_merge.push_back(temp_eom_model);
				eom_prod_no_nb_for_merge.push_back(temp_eom_no_nb);
				new_business_for_merge.push_back(temp_new_business);

				log_strm<<prod_key<<" aging policies setup done\n"<<"\n";
			}

			back_ground bg(product_configurations_out,
							tot_nb_workers,
							w_id,
							trace_log_pth_out,
							ap_conf);

			log_strm<<endl;
			merge_multi(ap_conf->get_eom_model(),eom_model_for_merge);
			log_strm<<ap_conf->get_eom_model()<<" merged \n";
			merge_multi(ap_conf->get_eom_prod_no_nb(),eom_prod_no_nb_for_merge);
			log_strm<<ap_conf->get_eom_prod_no_nb()<<" merged \n";
			merge_multi(ap_conf->get_new_business(),new_business_for_merge);
			log_strm << ap_conf->get_new_business()<<" merged \n";
			log_strm << endl;

			delete ap_conf;
			log_strm << "Projections ended correctly " << endl;

			return 1;
	}
	catch(GMXBException *e)
	{
		    cout << e->get_message()  << endl;
			log_strm << "Error from dll : " << e->get_message() << endl;
			throw new GMXBException("");
	}
	return 0;

}

int InterfaceSummarizeHE(string& config,ofstream& log_strm, int nbWorker,int idWorker,  string& s)
{
	try 
	{
		int nb_workers_used;

		//Dispatcher
		string s_nb_workers_used, s_run_config;
		int virg=0;
		for(int i=0;i<s.size();i++){
			if(s[i]==',') virg++;
			else if(virg==0)
				s_nb_workers_used.push_back(s[i]);
			else{
				s_run_config.push_back(s[i]);	
			}
		}
	
		//nb_workers_used=atoi(s_nb_workers_used.c_str());
		
		//Local
		//nb_workers_used=atoi(s.c_str());


		log_strm << " begin summarize Hedge effectiveness " << endl;

			//WildcardManager wm( config, "wildcards" );
		   // GMXBParameters HEparameter( config, "main_application" );	
			//Ali Change : to use different config files in the dispatcher
			WildcardManager wm( s_run_config, "wildcards" );
		    GMXBParameters HEparameter( s_run_config, "main_application" );	

			ofstream logStrm_out( wm.getPath(HEparameter.search("Log_Outer")).c_str() );
			ofstream logStrm_in( wm.getPath(HEparameter.search("Log_Inner")).c_str() );

		string parameter_file_out=wm.getPath(HEparameter.search("Projection_Outer"));
		string parameter_file_in=wm.getPath(HEparameter.search("Projection_Inner"));

		vector<Product_configuration> product_configurations_out, product_configurations_in;
		Bucket_list bucket_list_table;
		vector<Summary_configuration> summary_configurations;
		back_ground bg;
	
		string trace_log_pth_out, trace_log_pth_in;;

		HE_configuration* he_conf = new HE_configuration();

		load_he_configuration(parameter_file_out, he_conf);

		load_run_configuration_he_outer(parameter_file_out,
				product_configurations_out, 
				trace_log_pth_out, true);

		load_run_configuration_esg(parameter_file_in, 
								product_configurations_in, 
								trace_log_pth_in,
								false);

		load_summarization_configuration_HE(parameter_file_out, 
				summary_configurations, product_configurations_out, product_configurations_in);


		bg.summarize_he_results(summary_configurations, he_conf, nb_workers_used);
		

		delete he_conf;

		log_strm << " end of summarize Hedge effectiveness " << endl;

		return 1;
	}	
	catch(GMXBException *e)
	{
			log_strm << "Error from dll : " << e->get_message() << endl;
			delete e;
	}
	return 0;
}

int InterfacePriceHeAsset(string& config, ofstream& log_strm, int tot_nb_workers, int w_id, string& s){
	try
	{

		log_strm << " begin price asset Hedge effectiveness " << endl;
		log_strm << " config: " << config << endl;
		WildcardManager wm_0( config, "wildcards" );

		GMXBParameters HEparameter( config, "main_application" );	
		
		ofstream logStrm_out( wm_0.getPath(HEparameter.search("Log")).c_str() );
		
		string Projection_asset=HEparameter.search("Projection_asset");

		log_strm << " Projection_asset :  " << Projection_asset << endl;
		
		istringstream config_file_list(Projection_asset);
		string run_conf_i;
		std::vector<std::string> list_run_conf;
		while (getline(config_file_list, run_conf_i, ','))
		{
			list_run_conf.push_back(run_conf_i);
		}
		int p = 0;
		for ( int i = 0; i < list_run_conf.size(); ++i)
		{
			log_strm << "run_conf_i=" << i<< ": " << wm_0.getPath(list_run_conf[i]) << endl; 
			p += price_he_asset(wm_0.getPath(list_run_conf[i]), log_strm, tot_nb_workers, w_id, s);
			log_strm << "p=" << p<< endl;
		}
		return 1;
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll (Stat inforce) : " << e->get_message() << endl;
	}
	return 0;
}

int price_he_asset(string& parameter_file, ofstream& log_strm, int tot_nb_workers, int w_id, string& s)
{
try
{
	#pragma region Load the configuration sheets from the parameter_file
		map<string, vector<string> > map_of_scenarios;
		map<string, vector<string> > map_HE_asset;
		map<string, vector<string> > map_Delta_hedging;
		map<string, vector<string> > map_Gamma_hedging;
		map<string, vector<string> > map_rho_hedging;
		map<string, vector<string> > map_rho_convexity_hedging;
		
		GMXBExcelXMLReader xml_reader(parameter_file);

		xml_reader.parse_XML_sheet("HE_asset", map_HE_asset);							// principal parameters for Hedge Effectiveness (input & output)
		xml_reader.parse_XML_sheet("Delta_hedging", map_Delta_hedging);					// for delta hedging
		xml_reader.parse_XML_sheet("Gamma_hedging", map_Gamma_hedging);					// for gamma hedging
		xml_reader.parse_XML_sheet("Rho_hedging", map_rho_hedging);						// for rho hedging
		xml_reader.parse_XML_sheet("Scenario", map_of_scenarios);						// define some complementary infos for rho heging (shocks, transaction cost by bucket, etc)
		xml_reader.parse_XML_sheet("RhoConvexity_hedging", map_rho_convexity_hedging);  // for rho convexity hedging <- to be defined
	#pragma endregion

		// --TODO--: add a check_assumption function to control the input from run configuration
		// --TODO--: add independent function to load (after verifying) run configuration for pricing and for summarize
				
	#pragma region From HE_asset sheet
		int nb_of_scen            = atoi(map_HE_asset["nb_scenario"][0].c_str());   // number of scenarios to hedge
		int nb_index_total        = atoi(map_HE_asset["nb_index_total"][0].c_str());
		int nb_index_to_hedge     = map_HE_asset["index_to_hedge"].size();
		
		#pragma region consistency check
			// consistency check: number of index to hedge should be less than number of index total
			if (nb_index_to_hedge > nb_index_total) // => exit
			{
				cout << "Number of index to hedge should be less than number of index total. Please check the run configuration, tab HE_Asset! \n";
				log_strm << "Number of index to hedge should be less than number of index total. Please check the run configuration, tab HE_Asset! \n";

				return 0; // Have to check why it crashes! => because of portfolio object's self-destructor => should declare it after this check
			}

			// consistency check: index to hedge should be in increasing order
			for (int i = 1; i < nb_index_to_hedge; ++i) // if more than one indexes to hedge
			{
				if (atoi(map_HE_asset["index_to_hedge"][i-1].c_str()) > atoi(map_HE_asset["index_to_hedge"][i].c_str()))
				{
					cout << "Index to hedge should be in increasing order. Please check the run configuration, tab HE_Asset! \n";
					log_strm << "Index to hedge should be in increasing order. Please check the run configuration, tab HE_Asset! \n";
					return 0;
				}
			}
			// consistency check: 
			if (atoi(map_HE_asset["index_to_hedge"][nb_index_to_hedge-1].c_str()) > nb_index_total)
			{
				cout << "Index to hedge should be less than " << nb_index_total << ". Please check the run configuration, tab HE_Asset! \n";
				log_strm << "Index to hedge should be less than " << nb_index_total << ". Please check the run configuration, tab HE_Asset! \n";
				return 0;
			}
		#pragma endregion

		// asset portfolio
		Portfolio portfolio;

		portfolio._config.g_nb_av			  = nb_index_total;           // number total of index available in the liability file
		portfolio._config.g_nb_index_to_hedge = nb_index_to_hedge;       
		portfolio._config.g_indexes_to_hedge  = new int[nb_index_to_hedge];

		for (int i = 0; i < nb_index_to_hedge; ++i)
		{
			portfolio._config.g_indexes_to_hedge[i] = atoi(map_HE_asset["index_to_hedge"][i].c_str());
		}

		portfolio._config.g_model_period      = atoi(map_HE_asset["model_period"][0].c_str());
		portfolio._config.g_nb_steps_per_year = atoi(map_HE_asset["nb_steps_per_year"][0].c_str());
		portfolio._config.g_rates_freq_ann    = (map_HE_asset["rates_freq_ann"][0] == "TRUE");
		
		// use if we want more details in the intermediate calculation
		portfolio._config._isDumpFutureNb     = (map_HE_asset["output_futures_info"][0] == "TRUE");
		portfolio._config._isDumpOptionNb     = (map_HE_asset["output_options_info"][0] == "TRUE");
		portfolio._config._isDumpSwapNb       = (map_HE_asset["output_swaps_info"][0] == "TRUE");
		portfolio._config._isDumpSwapRho      = (map_HE_asset["output_swaps_rho_info"][0] == "TRUE");
		
		string output_liability_file          = map_HE_asset["hedgeff_path"][0];
		string real_world_scenario_file       = map_HE_asset["rw_scn_path"][0]; 
		string output_intermediate_file       = map_HE_asset["output_intermediate_file"][0];

		// depend on format of liability file => may need to skip several columns
		portfolio._config.g_nb_column_skip_between_claims_and_charges = atoi(map_HE_asset["nb_column_SKIP_between_CLAIMS_and_CHARGES"][0].c_str());
		portfolio._config.g_nb_column_skip_between_charges_and_av     = atoi(map_HE_asset["nb_column_SKIP_between_CHARGES_and_AV"][0].c_str());
	#pragma endregion
				
	#pragma region From Delta_hedging sheet	
		portfolio._isHedgeDelta                       = (map_Delta_hedging["hedge_delta"][0] == "TRUE");

		portfolio._config.g_reb_freq_delta            = atoi(map_Delta_hedging["reb_freq_delta"][0].c_str());
		portfolio._config.g_delta_trans_cost          = atof(map_Delta_hedging["delta_transaction_cost"][0].c_str());
		portfolio._config.g_length_of_future_contract = atoi(map_Delta_hedging["length_of_futures_contract"][0].c_str());
		portfolio._config.g_sheduled_futures          = (map_Delta_hedging["sheduled_futures"][0] == "TRUE");
		portfolio._config.g_index_base                = atof(map_Delta_hedging["index_bases"][0].c_str());

		//int next_time_step_sheduled = atoi(map_Delta_hedging["next_time_step_sheduled"][0].c_str()); // => no need anymore?	
		//double delta_per_cont=atof(map_Delta_hedging["delta_per_cont"][0].c_str());                  // => no need anymore?
		#pragma endregion

	#pragma region From Gamma_hedging sheet
		portfolio._isHedgeGamma                       = (map_Gamma_hedging["hedge_gamma"][0] == "TRUE");

		portfolio._config.g_reb_freq_gamma            = atoi(map_Gamma_hedging["reb_freq_gamma"][0].c_str());
		portfolio._config.g_reb_freq_gamma            = atoi(map_Gamma_hedging["reb_freq_gamma"][0].c_str());
		portfolio._config.g_moneyness                 = atof(map_Gamma_hedging["moneyness"][0].c_str());
		portfolio._config.g_volatility                = atof(map_Gamma_hedging["volatility"][0].c_str());
		portfolio._config.g_length_of_option_contract = atoi(map_Gamma_hedging["length_of_option_contract"][0].c_str());
		portfolio._config.g_sell_at_time_to_expiry    = atoi(map_Gamma_hedging["sell_at_time_to_expiry"][0].c_str());

		portfolio._config.g_net_gamma_lower_bound     = atof(map_Gamma_hedging["net_gamma_lower_bound"][0].c_str());
		portfolio._config.g_net_gamma_upper_bound     = atof(map_Gamma_hedging["net_gamma_upper_bound"][0].c_str());
		portfolio._config.g_liab_gamma_lower_bound    = atof(map_Gamma_hedging["liab_gamma_lower_bound"][0].c_str());
		portfolio._config.g_liab_gamma_upper_bound    = atof(map_Gamma_hedging["liab_gamma_upper_bound"][0].c_str());

		//int gamma_per_cont = atof(map_Gamma_hedging["gamma_per_cont"][0].c_str());                   // => no need anymore?
	#pragma endregion

	#pragma region From Rho_hedging sheet
		portfolio._isHedgeRho                      = (map_rho_hedging["hedge_rho"][0] == "TRUE");
		
		portfolio._config.g_reb_freq_rho           = atoi(map_rho_hedging["reb_freq_rho"][0].c_str());
		portfolio._config.g_unwind_swap            = (map_rho_hedging["unwind_swap"][0] == "TRUE"); 
		portfolio._config.g_swap_trade_lower_seuil = atof(map_rho_hedging["unwind_swap_lower_seuil"][0].c_str()); 
		
		// Modified 11/01/2011
		if (map_rho_hedging["unwind_swap_upper_seuil"][0] == "MAX") // seuil is infinity or in other word it's not be used
		{
			portfolio._config.g_swap_trade_upper_seuil = 0.0; // initiated anyway
			portfolio._config.g_swap_trade_NO_upper_seuil = true;
		}
		else
		{
			portfolio._config.g_swap_trade_upper_seuil = atof(map_rho_hedging["unwind_swap_upper_seuil"][0].c_str());
			portfolio._config.g_swap_trade_NO_upper_seuil = false;
		}

		//// special case if we only need the lower seuil for the unwind // pb compilation, desactivated for now
		//if (portfolio._config.g_swap_trade_upper_seuil < portfolio._config.g_swap_trade_lower_seuil)
		//{
		//	portfolio._config.g_swap_trade_upper_seuil = numeric_limits<double>::max();
		//}
	#pragma endregion

	#pragma region From Scenario sheet // for IR shocks and transaction cost by bucket
		int nb_maturities_to_hedge                  = map_of_scenarios["key_rate"].size();
		portfolio._config.g_nb_lbs_maturities       = nb_maturities_to_hedge;
		
		portfolio._config.g_lbs_maturities          = new int[nb_maturities_to_hedge];    // buckets to hedge
		portfolio._config.g_start_ma                = new int[nb_maturities_to_hedge];    // starting maturity to apply shock
		portfolio._config.g_end_ma                  = new int[nb_maturities_to_hedge];    // ending maturity to apply shock
		portfolio._config.g_shocks                  = new double[nb_maturities_to_hedge]; // shock apply for each bucket

		portfolio._config.g_compounding_frequencies = new int[nb_maturities_to_hedge];    // swap frequency
		portfolio._config.g_swap_spread             = new double[nb_maturities_to_hedge]; // spread apply for each swap transaction (only buying, not unwind)
	
		for (int i = 0; i < nb_maturities_to_hedge ; ++i)
		{
			portfolio._config.g_lbs_maturities[i]          = atoi(map_of_scenarios["key_rate"][nb_maturities_to_hedge-1-i].c_str()); // in reverse direction
			portfolio._config.g_start_ma[i]                = atoi(map_of_scenarios["start_rate"][nb_maturities_to_hedge-1-i].c_str());
			portfolio._config.g_end_ma[i]                  = atoi(map_of_scenarios["end_rate"][nb_maturities_to_hedge-1-i].c_str());
			portfolio._config.g_shocks[i]                  = atof(map_of_scenarios["shocks_to_apply"][nb_maturities_to_hedge-1-i].c_str());

			portfolio._config.g_compounding_frequencies[i] = atoi(map_of_scenarios["compounding_frequencies"][nb_maturities_to_hedge-1-i].c_str());
			portfolio._config.g_swap_spread[i]             = atof(map_of_scenarios["rho_transaction_cost"][nb_maturities_to_hedge-1-i].c_str())/10000.0; // to be checked!
		}
	#pragma endregion 

	#pragma region From RhoConvexity_hedging sheet => not yet integrated. 
		portfolio._isHedgeRhoConv = (map_rho_convexity_hedging["hedge_rho_convexity"][0] == "TRUE");
		// To be defined!!!
	#pragma endregion

	#pragma region Hedge Effectiveness	
		// --TODO--: should be adapted with all cases
		// for instance, ONLY WORKING IF NUMBER OF SCENARIOS !!!EQUAL TO!!! NUMBER OF WORKERS
		int start_scn = nb_of_scen/tot_nb_workers * (w_id - 1) + 1;
		int end_scn = nb_of_scen/tot_nb_workers * w_id ;
		
		// load config from liability file & scenario file
		portfolio.loadConfig("", output_liability_file, real_world_scenario_file);
		
		// start to hedge
		portfolio.hedging(output_liability_file, real_world_scenario_file, start_scn, end_scn, output_intermediate_file, log_strm);
	#pragma endregion

		// clean memory // => DONE in the destruction of Portfolio
		//delete index_to_hedge; 

		return 1;
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll (Stat inforce) : " << e->get_message() << endl;
	}
	return 0;
}

int summarize_he_asset(string& parameter_file,ofstream& log_strm, int tot_nb_workers, int w_id_, string& s)
{
	try
	{
		map<string, vector<string> > map_HE_asset;
		
		// read the HE_asset sheet
		GMXBExcelXMLReader xml_reader(parameter_file);
		xml_reader.parse_XML_sheet("HE_asset", map_HE_asset);

		int nb_of_scen=atoi(map_HE_asset["nb_scenario"][0].c_str());
		string intermediate_file = map_HE_asset["output_intermediate_file"][0];
		string output_path = map_HE_asset["output_path"][0];
		string output_file_name = map_HE_asset["output_file_name"][0];

		char output_file_n[MAX_LENGTH_FILE_NAME];

		sprintf(output_file_n, "%s%s", output_path.c_str(), output_file_name.c_str());
		ofstream out(output_file_n);
		
		// added 08/12/2010
		int nb_workers_used = tot_nb_workers;     
		if (s != "") // only if we run with dispatcher
		{
			nb_workers_used = atoi(s.c_str()); // using for dispatcher  
		}
		
		for (int w_id = 1; w_id <= nb_workers_used; ++w_id)
		{
			char file_name[MAX_LENGTH_FILE_NAME];
			
			// --TODO--: should be adapted with all cases
			// for instance, ONLY WORKING IF NUMBER OF SCENARIOS !!!EQUAL TO!!! NUMBER OF WORKERS
			int start_scn = nb_of_scen/nb_workers_used * (w_id - 1) + 1;
			int end_scn   = nb_of_scen/nb_workers_used * w_id ;

			ostringstream str_scn;
			ostringstream ed_scn;

			str_scn << start_scn;
			ed_scn << end_scn;

			string file_to_find = intermediate_file + "_" + str_scn.str() + "_"  + ed_scn.str() + ".csv";
			sprintf(file_name, "%s", file_to_find.c_str());

			ifstream file_op(file_name, ios::in);
			string row;
			if (file_op)
			{
				getline(file_op,row);
				// Skip the first line except for the first worker

				if (w_id == 1)
				{
					if (row.length() > 0)
					{
						// Copy the header
						out << row.c_str() << endl;
					}
				}

				while(!file_op.eof())
				{
					getline(file_op,row);
					if (row.length() > 0)
					{
						out << row.c_str() << endl;
					}
				}
			}
			else
			{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "Summarization: The file %s is not found", file_name);
					throw new GMXBException(message);
			}

			file_op.close();
		}
	
		out.close();

		return 1;
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll (Stat inforce) : " << e->get_message() << endl;
	}
	return 0;
}

int InterfaceSummarizeHeAsset(string& config, ofstream& log_strm, int tot_nb_workers, int w_id_, string& s)
{
	try
	{
		log_strm << " begin summarize asset Hedge effectiveness " << endl;

		WildcardManager wm_0( config, "wildcards" );

		GMXBParameters HEparameter( config, "main_application" ); 

		ofstream logStrm_out( wm_0.getPath(HEparameter.search("Log")).c_str() );

		string Projection_asset = HEparameter.search("Projection_asset");

		//string parameter_file_liste=wm_0.getPath(HEparameter.search("Projection_asset"));
		istringstream config_file_list(Projection_asset);

		string run_conf_i;

		while (getline(config_file_list, run_conf_i, ','))
		{
			int p = summarize_he_asset(wm_0.getPath(run_conf_i), log_strm, tot_nb_workers, w_id_, s);
		}

		return 1;
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll (Stat inforce) : " << e->get_message() << endl;
	}
	return 0;
}
