#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#include <ctime>
#include <string>
#include <fstream>
#include <sstream>
#include <time.h>
#include <dos.h>

#include "Utility classes/stdafx.h"
#include "Utility classes/head.h"
#include "back_ground_final.h"

#include "GMXBExcelXMLReader.h"
#include "GMXBException.h"
#include "GMXBParameters.h"
#include "WildcardManager.h"

#include "../ESG_V0/Instruments/InterfaceESG0.h"
#include "../ESG_V0/Calibration/HW1FCalibrator.h"
#include "../ESG_V0/Scenario/ScenarioGen.h"

#include "safe_reader.h"


#define REFERENCE_FILE 0
#define FILE_TO_COMPARE 1
#define OUTPUT_RESULTS 2

/*
* price a set of product (defined in parameter_file)
* with a table of scenarios build by an external program. 
* This method is called by MoSes
* string& parameter_file : file containing the description of the payoffs
* ofstream& log_strm : stream used for logging
* double*** va_scen : scenarios (generated by MoSes)
* int scen_pass_number: id of the scenario
* int tot_nb_workers : total number of workers
* int w_id : id of the current worker
* double alpha : alpha parameter (calibration)
* double sigma : sigma parameter (calibration)
*/
extern "C"
{
	// Launch calibration standalone with the DLL (changed)
	_declspec (dllexport) int run_calibration_standalone(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

	// ESG stand alone ( previous)
	_declspec (dllexport) int run_esg_standalone(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

	// ESG stand alone (Baloise)
	_declspec (dllexport) int TEST_NEW_CALIB(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s);
	
	//Launch ESG and projection ( Baloise)
	_declspec (dllexport) int ALI_BL_esg_projection_V2(string& config_Projection, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

	//Launch projection with a set of scenario file
	_declspec (dllexport) int run_HA_file_mode(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string& s);

}

ofstream trace;
ofstream trace_out;
ofstream trace_in;

// Launch calibration standalone with the DLL (changed)
int __cdecl run_calibration_standalone(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s)
{
	UNREFERENCED_PARAMETER(idWorker);
	UNREFERENCED_PARAMETER(nbWorker);
	UNREFERENCED_PARAMETER(s);
	try
	{
		 WildcardManager wm( config, "wildcards" );
		 GMXBParameters ESGparameter( config, "main_application" );	
		 string config_calib = wm.getPath(ESGparameter.search("Esg_configuration"));

		 log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;	 
		 log_strm << "config_calib = " << config_calib << endl;
		 double a,sigma;	 	 
		 ifstream conf_file(config_calib.c_str(), ios::in);	 
		 if (conf_file){ 	
			InterfaceESG0* iEsg=new InterfaceESG0(config_calib);
			YC* Yield_curve_vector=new YC(iEsg);
			HW1FCalibrator *Calibrator=new HW1FCalibrator(iEsg,*Yield_curve_vector);
			HW1FSwaptionPricer *model=new HW1FSwaptionPricer(iEsg->Calib_Error_Function_Type,iEsg->Calibration_On,iEsg->Param_initial,iEsg->Param_min,iEsg->Param_max);
			double error=0.00000001;		
			Calibrator->calibrate(model,error,LM_NEW); //DFPMIN, LM_NEW
			a=model->getMRV();
			sigma=model->getsigma();
			delete  Calibrator;			
			delete model;
			delete Yield_curve_vector;
			delete  iEsg;
		 }
		 else{		
			 char message[MAX_LENGTH_MESSAGE_EXCEPTION];		
			 sprintf_s(message, "The file %s doesn't exist", config_calib.c_str());
			 throw new GMXBException(message);		 	
		 }			
		 return 1; 
	}
	catch(GMXBException *e)
	{
		log_strm << "Error from dll : " << e->get_message() << endl;
		cout << "Error from dll : " << e->get_message() << endl;
	}
	return 0;
}
// ESG stand alone ( previous)
int __cdecl run_esg_standalone(string& config, ofstream& log_strm, int nb_of_workers, int worker_id, string & s)
{
	UNREFERENCED_PARAMETER(nb_of_workers);
	UNREFERENCED_PARAMETER(s);
	UNREFERENCED_PARAMETER(worker_id);	
	WildcardManager wm(config, "wildcards");
	GMXBParameters parameter_main( config, "main_application" );	
	string config_esg = wm.getPath(parameter_main.search("Esg_configuration"));
	string Model_rand="Mersenne_Twister";
	string Model_diff="BS_HW1F";
	string Model_guassian="Polar";

	log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;
	ifstream conf_file1(config_esg.c_str(), ios::in);
	if (conf_file1)
	{ 
		InterfaceESG0* iEsg=new InterfaceESG0(config_esg);
		YC* Yield_curve_vector=new YC(iEsg);
		HW1FCalibrator *Calibrator=new HW1FCalibrator(iEsg,*Yield_curve_vector);
		HW1FSwaptionPricer *model=new HW1FSwaptionPricer(iEsg->Calib_Error_Function_Type,iEsg->Calibration_On,iEsg->Param_initial,iEsg->Param_min,iEsg->Param_max);	
		double error=0.00000001;		
		Calibrator->calibrate(model,error,LM_NEW); //DFPMIN, LM_NEW		
		ScenarioGen *scenario1=new ScenarioGen(iEsg,model,Yield_curve_vector,Model_rand,Model_guassian,Model_diff, 0);
		if(iEsg->Generate_All_Scenarios_In_One_Step==1) scenario1->Generate_Scenario();
		else{//Shouldn't be used in this mode
			for(int it=0; it <iEsg->Local_Number_Scenario/2;it++)
				scenario1->Generate_Scenario();
		}
		delete  scenario1;
		delete  Calibrator;			
		delete model;
		delete Yield_curve_vector;
		delete  iEsg;
	}
	const char* ESG = config.c_str();
	int n = 0;
	while(ESG[n]!='\0'){ n++;}
	char* ESG_fin = new char[n-3];
	for(int i=0;i<n-4;i++){ ESG_fin[i]=ESG[i]; }
	ESG_fin[n-4]='\0';
	string config_ESG2(ESG_fin);
	
	for(int scenario_pass_number=1; scenario_pass_number<=1000; scenario_pass_number++){
		stringstream ss;
		ss << scenario_pass_number;	 
		ifstream conf_file_1((config_ESG2 + "_" + ss.str() + ".xml").c_str(), ios::in);
		if (conf_file_1)
		{ 
			InterfaceESG0* iEsg=new InterfaceESG0(config_ESG2 + "_" + ss.str() + ".xml");
			YC* Yield_curve_vector=new YC(iEsg);
			HW1FCalibrator *Calibrator=new HW1FCalibrator(iEsg,*Yield_curve_vector);
			HW1FSwaptionPricer *model=new HW1FSwaptionPricer(iEsg->Calib_Error_Function_Type,iEsg->Calibration_On,iEsg->Param_initial,iEsg->Param_min,iEsg->Param_max);	
			double error=0.00000001;		
			Calibrator->calibrate(model,error,LM_NEW); //DFPMIN, LM_NEW		
			ScenarioGen *scenario1=new ScenarioGen(iEsg,model,Yield_curve_vector,Model_rand,Model_guassian,Model_diff, 0);
			if(iEsg->Generate_All_Scenarios_In_One_Step==1) scenario1->Generate_Scenario();
			else{//Shouldn't be used in this mode
				for(int it=0; it <iEsg->Local_Number_Scenario/2;it++)	
					scenario1->Generate_Scenario();
			}
			delete  scenario1;	
			delete  Calibrator;			
			delete model;
			delete Yield_curve_vector;
			delete  iEsg;
		}
	}

	delete[] ESG_fin;
	 
	return 1;
}
// ESG stand alone (Baloise)
int __cdecl TEST_NEW_CALIB(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s)
{
	UNREFERENCED_PARAMETER(s);
	UNREFERENCED_PARAMETER(idWorker);
	UNREFERENCED_PARAMETER(log_strm);
	UNREFERENCED_PARAMETER(nbWorker);
	try
	{
		WildcardManager wm(config, "wildcards");
		GMXBParameters parameter_main( config, "main_application" );	
		string config_esg = wm.getPath(parameter_main.search("Esg_configuration"));
		
		ifstream conf_file1(config_esg.c_str(), ios::in);
		if (conf_file1)
		{ 
			cout << " initialise InterfaceESG0 " << endl;
			InterfaceESG0* iEsg=new InterfaceESG0(config_esg);

			cout << " initialise Yield curve " << endl;
			YC* Yield_curve_vector=new YC(iEsg);
			
			//cout << " initialise shocked Yield curve " << endl;
			//string shock="baseline";
			//Yield_curve_vector->ShockSwap(20.,25.,60.,0.,shock);
			
			cout << " initialise Calibration " << endl;
			HW1FCalibrator *Calibrator=new HW1FCalibrator(iEsg,*Yield_curve_vector);

			cout << " initialise Model HW1F for calibration " << endl;
			HW1FSwaptionPricer *model=new HW1FSwaptionPricer(iEsg->Calib_Error_Function_Type,iEsg->Calibration_On,iEsg->Param_initial,iEsg->Param_min,iEsg->Param_max);

			cout << " Calibrate the model " << endl;		
			double error=0.00000001;		
			Calibrator->calibrate(model,error,LM_NEW); //DFPMIN, LM_NEW		
			cout << " Alpha= " << model->getMRV() << ",      Sigma= " << model->getsigma() <<  ",      Error= " << error <<  endl;

			
			cout << " Create SCenario class " << endl;
			string Model_rand="Mersenne_Twister";
			string Model_diff="BS_HW1F";
			string Model_guassian="Polar";
			ScenarioGen *scenario1=new ScenarioGen(iEsg,model,Yield_curve_vector,Model_rand,Model_guassian,Model_diff, 0);
			
			if(iEsg->Generate_All_Scenarios_In_One_Step==1)
				scenario1->Generate_Scenario();
			else{//Shouldn't be used in this mode
				for(int it=0; it <iEsg->Local_Number_Scenario/2;it++)
					scenario1->Generate_Scenario();
			}
							
			cout << " End Generating Scenarios " << endl;

			delete  scenario1;
			delete  Calibrator;			
			delete model;
			delete Yield_curve_vector;
			delete  iEsg;
			
			return 1;
		}
		else return 0;
	
	}
	catch(GMXBException *g)
	{
		cout <<g->get_message() << endl;
		getchar();
	}
	return 0;
}

/*
* This function load all the parameter in a run configuration files like the initial load run conf
* The only difference is on the reading the informations of buckets in scenario sheet
*/
//! Y: Add map_run_settings by yuan for: map_products_configuration/map_of_shock_settings/map_run_settings
void trimString(string& str)   
{   
    size_t startpos = str.find_first_not_of(" \t"); 
    size_t endpos = str.find_last_not_of(" \t"); 
    if(( string::npos == startpos ) || ( string::npos == endpos))   
    {   
        str = "";   
    }   
    else  
        str = str.substr( startpos, endpos-startpos+1 );
} 
void parse_index_esg(const string& string_to_parse, vector<vector<int>>& shock_array_vector, int index_number)
{
	istringstream index_streamed(string_to_parse);
	string delta_step;

	while (getline(index_streamed, delta_step, ';'))
	{
		vector<int> delta_steps;
		for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
			delta_steps.push_back(0);

			delta_steps[0] = index_number;
			delta_steps[index_number] = atoi(delta_step.c_str());
			shock_array_vector.push_back(delta_steps);
	}
}
void load_run_configuration_esg(string& parameter_file, vector<Product_configuration>& product_configurations, string& trace_log_p,bool use_scn_file)
{
	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string> > map_products_configuration;
		map<string, vector<string> > map_run_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		string list_of_prod_to_run = safe_map_read(map_run_settings,"list_of_products_to_run",0);
		trace_log_p = wm.getPath(safe_map_read(map_run_settings,"trace_log_path",0));

		map<string, vector<string> > map_bucket_list;
		xml_reader.parse_XML_sheet("bucket_list", map_bucket_list);

		//int bucket_id;
		double bucketStartDate=0.;
		double bucketKeyDate=0.;
		double bucketEndDate=0.;
		double bucketShockSize=0.;
		string bucket_type;

		// Load the "product_configuration" sheet
		xml_reader.parse_XML_sheet("product_configuration", map_products_configuration);

		istringstream list_of_runs_streamed(list_of_prod_to_run);
		string run_name;

		while (getline(list_of_runs_streamed, run_name, ','))
		{
			trimString(run_name);
			vector<string> list_of_configured_products = map_products_configuration["run_names"];
			// Try to find the run names
			int number_pf_configured_products = list_of_configured_products.size();
			if (number_pf_configured_products > 0)
			{
				bool found = false;
				int run_number = 0;
				for(int run_name_nb = 0 ; run_name_nb < number_pf_configured_products ; run_name_nb++)
				{
					if (list_of_configured_products[run_name_nb] == run_name)
					{
						found = true;
						run_number = run_name_nb;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The run name %s is not found in the product_configuration sheet (file %s) ", 
											run_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				vector<int> s_f_col;
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_0",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_1",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_2",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_3",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_4",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_5",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_6",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_7",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_8",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_9",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_10",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_11",run_number).c_str()));
						
				bool ext_all = false;
				if (safe_map_read(map_products_configuration,"extract_all_model_points",run_number) == "1") ext_all = true;

				bool generate_debug_files = false;
				if (safe_map_read(map_products_configuration,"generate_debug_files",run_number) == "1") generate_debug_files = true;

				int write_valo_pol_by_pol = atoi((safe_map_read(map_products_configuration,"write_valo_policy_by_policy",run_number)).c_str());
                if(write_valo_pol_by_pol >2 || write_valo_pol_by_pol<0)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "Error in function load_run_configuration_esg(...): write_valo_pol_by_pol's value %d should not be other than : 0 or 1 or 2 ",write_valo_pol_by_pol);
					throw new GMXBException(message);
				}

				// Build the product configuration object
				Product_configuration p_c(safe_map_read(map_products_configuration,"run_names",run_number),
						wm.getPath(safe_map_read(map_products_configuration,"inforce_file_name",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"product_feature_file_name",run_number)),
						safe_map_read(map_products_configuration,"product_code_key_names",run_number),
						atoi(safe_map_read(map_products_configuration,"number_of_model_points",run_number).c_str()),
						ext_all,s_f_col,
						wm.getPath(safe_map_read(map_products_configuration,"result_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"debug_file_path",run_number)),
						atoi(safe_map_read(map_products_configuration,"number_of_scenarios",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"yield_col_for_pv_index",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"lapse_dyn_treas",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"indice_index_rate",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"index_number",run_number).c_str()), generate_debug_files,
						write_valo_pol_by_pol, /*atoi(safe_map_read(map_products_configuration,"modulo_on_scenario",run_number).c_str()),*/
						atoi(safe_map_read(map_products_configuration,"time_step",run_number).c_str()));

		
				istringstream shock_streamed(safe_map_read(map_products_configuration,"list_of_shocks",run_number));
				string shock_sheet;
				while (getline(shock_streamed, shock_sheet, ','))
				{
				trimString(shock_sheet);
				map<string, vector<string>> map_of_shock_settings;
				xml_reader.parse_XML_sheet(shock_sheet, map_of_shock_settings);

				int nb_bucket_to_project = atoi(safe_map_read(map_of_shock_settings,"nb_bucket_to_project",0).c_str());
				int scenario_pass_number = atoi(safe_map_read(map_of_shock_settings,"scenario_pass_number",0).c_str());

				//! CHECK if two same bucket_id are used(but may exist)in the same scnario config
				vector<int> bucket_id_check_vector;
				for(int iterator_bucket_id_check =0; iterator_bucket_id_check<nb_bucket_to_project; ++iterator_bucket_id_check)
				{
					bucket_id_check_vector.push_back(atoi(safe_map_read(map_of_shock_settings,"bucket_id",iterator_bucket_id_check).c_str())); 
				}
				vector<int>::iterator check_itr = bucket_id_check_vector.begin();
				vector<int>::iterator check_itr_end = bucket_id_check_vector.end();
				while(check_itr!=check_itr_end)
				{
						int bucket_to_find = *check_itr;
						++check_itr;
						if(find(check_itr,check_itr_end, bucket_to_find) != check_itr_end) // find two buckets in the same scenario!
						{
							char message[MAX_LENGTH_MESSAGE_EXCEPTION];
							sprintf_s(message, "Error in the scenario's bucket config: the scenario_pass_number %d use two same bucket_id %d",scenario_pass_number, bucket_to_find);
							throw new GMXBException(message);
						}
				}

				for(int iterator_bucket_id =0; iterator_bucket_id<nb_bucket_to_project; iterator_bucket_id++)
				{

					vector<vector<int> > index_shock_array;
					string run_baseline = safe_map_read(map_of_shock_settings,"run_baseline",iterator_bucket_id);
					string index_1 = safe_map_read(map_of_shock_settings,"index_1",iterator_bucket_id);
					string index_2 = safe_map_read(map_of_shock_settings,"index_2",iterator_bucket_id);
					string index_3 = safe_map_read(map_of_shock_settings,"index_3",iterator_bucket_id);
					string index_4 = safe_map_read(map_of_shock_settings,"index_4",iterator_bucket_id);
					string index_5 = safe_map_read(map_of_shock_settings,"index_5",iterator_bucket_id);
					string index_6 = safe_map_read(map_of_shock_settings,"index_6",iterator_bucket_id);
					string index_7 = safe_map_read(map_of_shock_settings,"index_7",iterator_bucket_id);
					string index_8 = safe_map_read(map_of_shock_settings,"index_8",iterator_bucket_id);
					string index_9 = safe_map_read(map_of_shock_settings,"index_9",iterator_bucket_id);
					string index_10 = safe_map_read(map_of_shock_settings,"index_10",iterator_bucket_id);
					string index_11 = safe_map_read(map_of_shock_settings,"index_11",iterator_bucket_id);
					string index_12 = safe_map_read(map_of_shock_settings,"index_12",iterator_bucket_id);
					string delta_global = safe_map_read(map_of_shock_settings,"delta_global",iterator_bucket_id);
						
					// Load informations about the buckets
					int bucket_id = atoi(safe_map_read(map_of_shock_settings,"bucket_id",iterator_bucket_id).c_str()); 

					for(map<string, vector<string>>::iterator bucket_list_iterator = map_bucket_list.begin();
						bucket_list_iterator!=map_bucket_list.end();
						bucket_list_iterator++)
					{
						if((*bucket_list_iterator).first == "id") continue;
						if( atoi((*bucket_list_iterator).first.c_str()) == bucket_id)
						{
							string key = (*bucket_list_iterator).first;
							bucketStartDate  = atof(safe_map_read(map_bucket_list,key,1).c_str() ); 
							bucketKeyDate    = atof(safe_map_read(map_bucket_list,key,2).c_str()); 
							bucketEndDate    = atof(safe_map_read(map_bucket_list,key,3).c_str()); 
							bucketShockSize  = atof(safe_map_read(map_bucket_list,key,4).c_str())/100.0; 	
							bucket_type      = map_bucket_list[key][0]; 
						}
					}


					if (run_baseline != "0")
					{
						vector<int> delta_step;
						for (int j = 0; j <= MAXIMUM_NUMBER_OF_INDEXES; j++)
							delta_step.push_back(0);
						index_shock_array.push_back(delta_step);
					}
					if (index_1  != "0")	parse_index_esg(index_1, index_shock_array, 1);
					if (index_2  != "0")	parse_index_esg(index_2 , index_shock_array, 2);
					if (index_3  != "0")	parse_index_esg(index_3 , index_shock_array, 3);
					if (index_4  != "0")	parse_index_esg(index_4 , index_shock_array, 4);
					if (index_5  != "0")	parse_index_esg(index_5 , index_shock_array, 5);
					if (index_6  != "0")	parse_index_esg(index_6 , index_shock_array, 6);
					if (index_7  != "0")	parse_index_esg(index_7 , index_shock_array, 7);
					if (index_8  != "0")	parse_index_esg(index_8 , index_shock_array, 8);
					if (index_9  != "0")	parse_index_esg(index_9 , index_shock_array, 9);
					if (index_10 != "0")	parse_index_esg(index_10 , index_shock_array, 10);
					if (index_11 != "0")	parse_index_esg(index_11 , index_shock_array, 11);
					if (index_12 != "0")	parse_index_esg(index_12 , index_shock_array, 12);
					if (delta_global  != "0")
					{
						istringstream index_streamed(delta_global);
						string delta_step;
						while (getline(index_streamed, delta_step, ';'))
						{	
							vector<int> delta_steps;
							for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
								delta_steps.push_back(atoi(delta_step.c_str()));
							delta_steps[0] = MAXIMUM_NUMBER_OF_INDEXES + 1;
							index_shock_array.push_back(delta_steps);
						}
					}

					Scenario_configuration s_c("Nothing used",scenario_pass_number,index_shock_array,bucketStartDate,bucketKeyDate,
												bucketEndDate,bucketShockSize,bucket_type, bucket_id,use_scn_file);

					p_c.add_scenario_configuration(s_c);
				}
				}
				product_configurations.push_back(p_c);
			}
			else{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the run names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}
//Launch ESG and projection ( Baloise)
int __cdecl ALI_BL_esg_projection_V2(string& config_projection, ofstream& log_strm, int nb_of_workers, int worker_id, string& s)
{
	UNREFERENCED_PARAMETER(s);
	log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;

	double begin = clock();
	WildcardManager wm( config_projection, "wildcards" );
	GMXBParameters parameter_main( config_projection, "main_application" );	
	string config_projection_bis = wm.getPath(parameter_main.search("Projection_configuration"));

 	try{
		vector<Product_configuration> product_configurations;
		string trace_log_pth;
		
		load_run_configuration_esg(config_projection_bis,product_configurations,trace_log_pth,false);

		Dispatch_Manager dispatch_manager(product_configurations, config_projection_bis);
		back_ground bg(product_configurations,trace_log_pth,log_strm, nb_of_workers,worker_id,dispatch_manager);

		double end = clock();
		log_strm << endl << "Execution time for worker : " << worker_id << " is : "  << end - begin << endl;
		return 1;
	}	
	catch(GMXBException *e){
		log_strm << "Error from dll : " << e->get_message() << endl;
		cout << "Error from dll : " << e->get_message() << endl;
		delete e;
	}
		return 0;
}


//! Y: Add map_run_settings by yuan for: map_products_configuration/map_of_shock_settings/map_run_settings
void parse_index(const string& string_to_parse, vector<vector<int>>& shock_array_vector, int index_number)
{
	istringstream index_streamed(string_to_parse);
	string delta_step;

	while (getline(index_streamed, delta_step, ';'))
	{
		vector<int> delta_steps;
		for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
			delta_steps.push_back(0);

			delta_steps[0] = index_number;
			delta_steps[index_number] = atoi(delta_step.c_str());
			shock_array_vector.push_back(delta_steps);
	}
}
void load_run_configuration(string& parameter_file, vector<Product_configuration>& product_configurations, string& trace_log_p,bool use_scn_file)
{

	ifstream file_op(parameter_file.c_str() , ios::in);
	if (file_op)
	{
		map<string, vector<string> > map_products_configuration;
		map<string, vector<string> > map_run_settings;
		GMXBExcelXMLReader xml_reader(parameter_file);
		WildcardManager wm( parameter_file, "wildcards" ); 

		// Load the "runs_configuration" sheet
		xml_reader.parse_XML_sheet("runs_configuration", map_run_settings);
		string list_of_prod_to_run = safe_map_read(map_run_settings,"list_of_products_to_run",0);
		trace_log_p = wm.getPath(safe_map_read(map_run_settings,"trace_log_path",0));
		
		// Load the "product_configuration" sheet
		xml_reader.parse_XML_sheet("product_configuration", map_products_configuration);

		istringstream list_of_runs_streamed(list_of_prod_to_run);
		string run_name;
		while (getline(list_of_runs_streamed, run_name, ','))
		{
			trimString(run_name);
			vector<string> list_of_configured_products = map_products_configuration["run_names"];
			// Try to find the run names
			int number_pf_configured_products = list_of_configured_products.size();
			if (number_pf_configured_products > 0)
			{
				bool found = false;
				int run_number = 0;
				for(int run_name_nb = 0 ; run_name_nb < number_pf_configured_products ; run_name_nb++)
				{
					if (list_of_configured_products[run_name_nb] == run_name)
					{
						found = true;
						run_number = run_name_nb;
						break;
					}
				}
				if (!found)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "The run name %s is not found in the product_configuration sheet (file %s) ", 
											run_name.c_str(), parameter_file.c_str());
					throw new GMXBException(message);
				}

				vector<int> s_f_col;		
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_0",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_1",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_2",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_3",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_4",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_5",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_6",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_7",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_8",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_9",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_10",run_number).c_str()));
				s_f_col.push_back(atoi(safe_map_read(map_products_configuration,"scen_fund_col_11",run_number).c_str()));
						
				bool ext_all = false;
				if (safe_map_read(map_products_configuration,"extract_all_model_points",run_number) == "1") ext_all = true;

				bool generate_debug_files = false;
				if (safe_map_read(map_products_configuration,"generate_debug_files",run_number) == "1") generate_debug_files = true;

				int write_valo_pol_by_pol = atoi(safe_map_read(map_products_configuration,"write_valo_policy_by_policy",run_number).c_str());
                if(write_valo_pol_by_pol >2 || write_valo_pol_by_pol<0)
				{
					char message[MAX_LENGTH_MESSAGE_EXCEPTION];
					sprintf_s(message, "Error in function load_run_configuration(...): write_valo_pol_by_pol's value %d should not be other than : 0 or 1 or 2 ",write_valo_pol_by_pol);
					throw new GMXBException(message);
				}
				
				// Build the product configuration object
				Product_configuration p_c(safe_map_read(map_products_configuration,"run_names",run_number),
						wm.getPath(safe_map_read(map_products_configuration,"inforce_file_name",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"product_feature_file_name",run_number)),
						safe_map_read(map_products_configuration,"product_code_key_names",run_number),
						atoi(safe_map_read(map_products_configuration,"number_of_model_points",run_number).c_str()),
						ext_all,s_f_col,
						wm.getPath(safe_map_read(map_products_configuration,"result_file_path",run_number)),
						wm.getPath(safe_map_read(map_products_configuration,"debug_file_path",run_number)),
						atoi(safe_map_read(map_products_configuration,"number_of_scenarios",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"yield_col_for_pv_index",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"lapse_dyn_treas",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"indice_index_rate",run_number).c_str()),
						atoi(safe_map_read(map_products_configuration,"index_number",run_number).c_str()), generate_debug_files,
						write_valo_pol_by_pol, /*atoi(safe_map_read(map_products_configuration,"modulo_on_scenario",run_number).c_str()),*/
						atoi(safe_map_read(map_products_configuration,"time_step",run_number).c_str()));
				
				// Handle the list of shocks
				istringstream shock_streamed(safe_map_read(map_products_configuration,"list_of_shocks",run_number));
				string shock_sheet;
				while (getline(shock_streamed, shock_sheet, ','))
				{
					trimString(shock_sheet);
					map<string, vector<string>> map_of_shock_settings;
					xml_reader.parse_XML_sheet(shock_sheet, map_of_shock_settings);

					string scenario_file = wm.getPath(safe_map_read(map_of_shock_settings,"scenario_file_path",0));
					int scenario_pass_number = atoi(safe_map_read(map_of_shock_settings,"scenario_pass_number",0).c_str());
					vector<vector<int> > index_shock_array;

					string run_baseline = safe_map_read(map_of_shock_settings,"run_baseline",0);
					string index_1 = safe_map_read(map_of_shock_settings,"index_1",0);
					string index_2 = safe_map_read(map_of_shock_settings,"index_2",0);
					string index_3 = safe_map_read(map_of_shock_settings,"index_3",0);
					string index_4 = safe_map_read(map_of_shock_settings,"index_4",0);
					string index_5 = safe_map_read(map_of_shock_settings,"index_5",0);
					string index_6 = safe_map_read(map_of_shock_settings,"index_6",0);
					string index_7 = safe_map_read(map_of_shock_settings,"index_7",0);
					string index_8 = safe_map_read(map_of_shock_settings,"index_8",0);
					string index_9 = safe_map_read(map_of_shock_settings,"index_9",0);
					string index_10 = safe_map_read(map_of_shock_settings,"index_10",0);
					string index_11 = safe_map_read(map_of_shock_settings,"index_11",0);
					string index_12 = safe_map_read(map_of_shock_settings,"index_12",0);
					string delta_global = safe_map_read(map_of_shock_settings,"delta_global",0);


					if (run_baseline != "0")
					{
						vector<int> delta_step;
						for (int j = 0; j <= MAXIMUM_NUMBER_OF_INDEXES; j++)
							delta_step.push_back(0);
						index_shock_array.push_back(delta_step);
					}
					if (index_1 != "0")		parse_index(index_1, index_shock_array, 1);
					if (index_2 != "0")		parse_index(index_2 , index_shock_array, 2);
					if (index_3 != "0")		parse_index(index_3 , index_shock_array, 3);
					if (index_4 != "0")		parse_index(index_4 , index_shock_array, 4);
					if (index_5 != "0")		parse_index(index_5 , index_shock_array, 5);
					if (index_6 != "0")		parse_index(index_6 , index_shock_array, 6);
					if (index_7 != "0")		parse_index(index_7 , index_shock_array, 7);
					if (index_8 != "0")		parse_index(index_8 , index_shock_array, 8);
					if (index_9 != "0")		parse_index(index_9 , index_shock_array, 9);
					if (index_10 != "0")	parse_index(index_10 , index_shock_array, 10);
					if (index_11  != "0")	parse_index(index_11 , index_shock_array, 11);
					if (index_12  != "0")	parse_index(index_12 , index_shock_array, 12);
					if (delta_global  != "0")
					{
						istringstream index_streamed(delta_global);
						string delta_step;
						while (getline(index_streamed, delta_step, ';'))
						{	
							vector<int> delta_steps;
							for (int i = 0; i <= MAXIMUM_NUMBER_OF_INDEXES; i++)
								delta_steps.push_back(atoi(delta_step.c_str()));
							delta_steps[0] = MAXIMUM_NUMBER_OF_INDEXES + 1;
							index_shock_array.push_back(delta_steps);
						}
					}

					Scenario_configuration s_c(scenario_file,scenario_pass_number,index_shock_array,use_scn_file);
					p_c.add_scenario_configuration(s_c);
				}
				product_configurations.push_back(p_c);
			}
			else{
				char message[MAX_LENGTH_MESSAGE_EXCEPTION];
				sprintf_s(message, "The size of the run names is 0");
				throw new GMXBException(message);
			}
		}
	}
	else{
		char message[MAX_LENGTH_MESSAGE_EXCEPTION];
		sprintf_s(message, "The file %s is not found", parameter_file.c_str());
		throw new GMXBException(message);
	}
}
//Launch projection with a set of scenario file
int __cdecl run_HA_file_mode(string& config, ofstream& log_strm, int nbWorker, int idWorker, string& s)//double alpha, double sigma)
{
	try{
		WildcardManager wm( config, "wildcards" );
		GMXBParameters parameter_main( config, "main_application" );	
		string config_projection = wm.getPath(parameter_main.search("Projection_configuration"));
		ostringstream sgstr;
		sgstr<<nbWorker;
	
		int p=0;
		try {
			vector<Product_configuration> product_configurations;
			string trace_log_pth;
			log_strm << "Version " << DLL_VERSION << " of the DLL " << endl;
	
			double alpha, sigma;
			string s_alpha, s_sigma;
			int virg=0;
			for(unsigned int i=0;i<s.size();i++){
				if(s[i]==',') virg++;
				else if(virg==0)
					s_alpha.push_back(s[i]);
				else{
					s_sigma.push_back(s[i]);	
				}
			}
		
			alpha=atof(s_alpha.c_str());
			sigma=atof(s_sigma.c_str());

			load_run_configuration(config_projection, product_configurations, trace_log_pth, true);
			back_ground bg(product_configurations, nbWorker, idWorker, trace_log_pth, alpha, sigma);

			p= 1;
		}	
		catch(GMXBException *e)
		{
				log_strm << "Error from dll : " << e->get_message() << endl;
				cout << "Error from dll : " << e->get_message() << endl;
	
		}

		int result =1;
		if (p == 0 || result == 0)
			return 0;
		else
			return 1;
	}

	catch(GMXBException *g)
	{
		cout <<g->get_message() << endl;
		getchar();
	}
	return 0;
}






